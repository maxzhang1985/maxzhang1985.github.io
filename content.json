[{"title":"Core设计的Golang实现","date":"2020-05-28T16:51:56.000Z","path":"2020/05/28/Core设计的Golang实现/","text":"YoyoGoYoyoGo 是一个用 Go 编写的简单，轻便，快速的 Web 框架。 特色 漂亮又快速的路由器 中间件支持 (handler func &amp; custom middleware) 对 REST API 友好 没有正则表达式 受到许多出色的 Go Web 框架的启发 框架安装1go get github.com/maxzhang1985/yoyogo 简单的例子12345678910package mainimport ...func main() &#123; YoyoGo.CreateDefaultBuilder(func(router Router.IRouterBuilder) &#123; router.GET(\"/info\",func (ctx *Context.HttpContext) &#123; // 支持Group方式 ctx.JSON(200, Context.M&#123;\"info\": \"ok\"&#125;) &#125;) &#125;).Build().Run() //默认端口号 :8080&#125; 实现进度标准功能 [X] 打印Logo和日志（YoyoGo） [X] 统一程序输入参数和环境变量 (YoyoGo) [X] 简单路由器绑定句柄功能 [X] HttpContext 上下文封装(请求，响应) [X] 静态文件端点（静态文件服务器） [X] JSON 序列化结构（Context.M） [X] 获取请求文件并保存 [X] 获取请求数据（form-data，x-www-form-urlencoded，Json ，XML，Protobuf 等） [X] Http 请求的绑定模型（Url, From，JSON，XML，Protobuf）响应渲染功能 [X] Render Interface [X] JSON Render [X] JSONP Render [X] Indented Json Render [X] Secure Json Render [X] Ascii Json Render [X] Pure Json Render [X] Binary Data Render [X] TEXT [X] Protobuf [X] MessagePack [X] XML [X] YAML [X] File [X] Image [X] Template [X] Auto formater Render 中间件 [X] Logger [X] StaticFile [X] Router Middleware [ ] Session [ ] CORS [ ] GZip [X] Binding [ ] Binding Valateion 路由 [x] GET，POST，HEAD，PUT，DELETE 方法支持 [x] 路由解析树与表达式支持 [x] RouteData路由数据 (/api/:version/) 与 Binding的集成 [x] 路由组功能 [ ] MVC默认模板功能 [ ] 路由过滤器 Filter MVC [x] 路由请求触发Controller&amp;Action [X] Action方法参数绑定 [ ] 内部对象的DI化 [ ] 关键对象的参数传递 Dependency injection [X] 抽象集成第三方DI框架 [X] MVC模式集成 [ ] 框架级的DI支持功能 扩展 [ ] 配置 [ ] WebSocket [ ] JWT [ ] swagger [ ] GRpc [ ] OAuth2 [ ] Prometheus [ ] 安全 进阶范例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package mainimport ...func main() &#123; webHost := CreateCustomWebHostBuilder().Build() webHost.Run()&#125;// 自定义HostBuilder并支持 MVC 和 自动参数绑定功能，简单情况也可以直接使用CreateDefaultBuilder 。func CreateCustomBuilder() *YoyoGo.HostBuilder &#123; return YoyoGo.NewWebHostBuilder(). UseFastHttp(). //Server可以指定多种，这里使用FastHttp作为Server，后期也会实现gRPC和WebSocket //使用默认Server并指定协议和端口 UseServer(YoyoGo.DefaultHttps(\":8080\", \"./Certificate/server.pem\", \"./Certificate/server.key\")). Configure(func(app *YoyoGo.ApplicationBuilder) &#123; app.SetEnvironment(Context.Dev) app.UseStatic(\"Static\") app.UseEndpoints(registerEndpoints) // endpoint 路由绑定函数 app.UseMvc() // 开启MVC功能 app.ConfigureMvcParts(func(builder *Controller.ControllerBuilder) &#123; builder.AddController(contollers.NewUserController) &#125;) &#125;). ConfigureServices(func(serviceCollection *DependencyInjection.ServiceCollection) &#123; // 依赖注入方法 serviceCollection.AddTransientByImplements(models.NewUserAction, new(models.IUserAction)) &#125;). OnApplicationLifeEvent(getApplicationLifeEvent)&#125;//region endpoint 路由绑定函数func registerEndpoints(router Router.IRouterBuilder) &#123; router.GET(\"/error\", func(ctx *Context.HttpContext) &#123; panic(\"http get error\") &#125;) //POST 请求: /info/:id ?q1=abc&amp;username=123 router.POST(\"/info/:id\", func (ctx *Context.HttpContext) &#123; qs_q1 := ctx.Query(\"q1\") pd_name := ctx.Param(\"username\") userInfo := &amp;UserInfo&#123;&#125; _ = ctx.Bind(userInfo) // 手动绑定请求对象 strResult := fmt.Sprintf(\"Name:%s , Q1:%s , bind: %s\", pd_name, qs_q1, userInfo) ctx.JSON(200, Std.M&#123;\"info\": \"hello world\", \"result\": strResult&#125;) &#125;) // 路由组功能实现绑定 GET 请求: /v1/api/info router.Group(\"/v1/api\", func(router *Router.RouterGroup) &#123; router.GET(\"/info\", func (ctx *Context.HttpContext) &#123; ctx.JSON(200, Std.M&#123;\"info\": \"ok\"&#125;) &#125;) &#125;) // GET 请求: HttpContext.RequiredServices获取IOC对象 router.GET(\"/ioc\", func (ctx *Context.HttpContext) &#123; var userAction models.IUserAction _ = ctx.RequiredServices.GetService(&amp;userAction) ctx.JSON(200, Std.M&#123;\"info\": \"ok \" + userAction.Login(\"zhang\")&#125;) &#125;)&#125;//endregion//region 请求对象type UserInfo struct &#123; UserName string `param:\"username\"` Number string `param:\"q1\"` Id string `param:\"id\"`&#125;// ----------------------------------------- MVC 定义 ------------------------------------------------------// 定义Controllertype UserController struct &#123; *Controller.ApiController userAction models.IUserAction // IOC 对象参数&#125;// 构造器依赖注入func NewUserController(userAction models.IUserAction) *UserController &#123; return &amp;UserController&#123;userAction: userAction&#125;&#125;// 请求对象的参数化绑定type RegiserRequest struct &#123; Controller.RequestParam UserName string `param:\"username\"` Password string `param:\"password\"`&#125;// Register函数自动绑定参数func (this *UserController) Register(ctx *Context.HttpContext, request *RegiserRequest) ActionResult.IActionResult &#123; result := Controller.ApiResult&#123;Success: true, Message: \"ok\", Data: request&#125; return ActionResult.Json&#123;Data: result&#125;&#125;// use userAction interface by ioc func (this *UserController) GetInfo() Controller.ApiResult &#123; return this.OK(this.userAction.Login(\"zhang\"))&#125;// Web程序的开始与停止事件func fireApplicationLifeEvent(life *YoyoGo.ApplicationLife) &#123; printDataEvent := func(event YoyoGo.ApplicationEvent) &#123; fmt.Printf(\"[yoyogo] Topic: %s; Event: %v\\n\", event.Topic, event.Data) &#125; for &#123; select &#123; case ev := &lt;-life.ApplicationStarted: go printDataEvent(ev) case ev := &lt;-life.ApplicationStopped: go printDataEvent(ev) break &#125; &#125;&#125;","tags":[]},{"title":"基于Kubernetes服务发现机制的探讨(Non Service)","date":"2020-05-13T13:31:02.000Z","path":"2020/05/13/app-registry-k8s/","text":"服务注册注册中⼼作为一般的RPC/Web服务中的底层设施提供了服务进程元数据（IP, Port, Interface, Group,Method等）存储，被Watch的功能，每个服务进程均需接⼊同⼀组持久化的K/V介质集群（⽐如: zookeeper,etcdv3等)。各进程均需将本进程的元数据存储于注册中⼼，并且能够Watch到其他服务进程的元数据变化（包括创建，更新等）。 KubernetesKubernetes作为容器集群化管理⽅案管理资源的维度可主观的分为服务进程管理和服务接⼊管理。服务进程管理，主要体现⽅式为Pod设计模式加控制器模式，控制器保证具有特定标签（Kubernetes-Label）的Pod保持在恒定的数量（多删，少补）。服务接⼊管理，主要为Kubernetes-Service，该Service默认为具有特定标签（KubernetesLabel）的Pod统⼀提供⼀个VIP（Kubernetes-ClusterIP）所有需要请求该组Pod的请求都会按照round-robin的负载策略转发到真正提供服务的Pod。并且CoreDNS为该Kubernetes-Service提供集群内唯⼀的域名。 Service 与 RPC/Web服务存在的冲突点 Kubernetes-Service标准的资源对象具有的服务描述字段 中并未提供完整的服务进程元数据字段因此，⽆法直接使⽤Kubernetes-Service进⾏服务注册与发现。 RPC/Web服务的服务注册是基于每个进程的，每个服务进程均需进⾏独⽴的注册。 Kubernetes-Service默认为服务创建VIP，提供round-robin的负载策略也与RPC/Web服务⾃有的负载策略形成了冲突。 抛弃Service对象，选择Pod对象进⾏注册 Kubernetes-Service与RPC/Web服务现有架构的冲突导致RPC/Web服务在选择服务注册与发现的时候只能选择放弃该资源对象。 RPC/Web服务既然选择了每个RPC/Web服务进程独⽴注册，因此RPC/Web服务选择将该进程具有的独有的元数据写⼊运⾏该RPC/Web服务进程的Pod在Kubernetes中的Pod资源对象的描述信息中。 每个运⾏RPC/Web服务进程的Pod将本进程的元数据写⼊Kubernetes-Pod Annotations字段。为了避免与其他使⽤Annotations字段的Operator或者其他类型的控制器（Istio）的字段冲突，使⽤Key为 app.io/annotation value为具体存储的K/V对的数组的json编码后的base64编码。 样例：12345apiVersion: v1kind: Podmetadata: annotations: app.io/annotation: 5LiN55So55yL5LqG5bCx5piv5LiA5Liq5paH5pys5Y2P6K6u 由于每个RPC/Web服务的Pod均只负责注册本进程的元数据，因此Annotations字段⻓度也不会因为运⾏RPC/Web服务进程的Pod数量增加⽽增加。 服务发现解决掉了服务注册问题，接下来需要解决的是服务发现的问题。Kubernetes Api-Server提供了Watch的功能，可以观察特定namespace甚⾄整个集群内各类资源的变化。RPC/Web服务为了避免RPC/Web服务进程watch到与RPC/Web服务进程⽆关的Pod的变化，RPC/Web服务将watch的条件限制在当前Pod所在的namespace，以及 watch 具有 app.io/label Value为app.io-value 的Pod。在Watch到对应Pod的变化后实时更新本地Cache，并通过Registry提供的Subscribe通知建⽴在注册中⼼之上的服务集群管理，或者其他功能。 ⼯作流程 启动RPC/Web服务的Deployment或其他类型控制器使⽤Kubernetes Downward-Api将本Pod所在namespace通过环境变量的形式注⼊RPC/Web服务进程。 RPC/Web服务进程的Pod启动后通过环境变量获得当前的namespace以及该Pod名称， 调⽤Kubernetes-Apiserver PATCH 功能为本Pod添加Key为app.io/label Value为app.io-value的label。 RPC/Web服务进程调⽤Kubernetes-Apiserver 将本进程的元数据通过PATCH接⼝写⼊当前Pod的Annotations字段。 RPC/Web服务进程 LIST 当前namespace下其他具有同样标签的Pod，并解码对应的Annotations字段获取其他Pod的信息。 RPC/Web服务进程 WATCH 当前namespace下其他具有同样标签的Pod的Annotations的字段变化。 总结Kubernetes已经为其承载的服务提供了⼀套服务发现，服务注册，以及服务集群管理机制,⽽传统基于注册中心的服务，同时也拥有⾃成体系的服务集群管理。这两个功能点形成了冲突，在⽆法调谐两者的情况，如果选择保持⾃有的服务集群管理系，放弃Kubernetes-Service功能，将元数据直接写⼊到Kubernetes Pod内，依赖Kubernetes提供的Watch功能提供维护服务集群状态，也是不错的选择。","tags":[{"name":"k8s","slug":"k8s","permalink":"http://maxzhang1985.github.io/tags/k8s/"}]},{"title":"Kubernetes中 Pod 是怎样被驱逐的？","date":"2020-05-11T17:13:01.000Z","path":"2020/05/11/k8s-pod-coutdown/","text":"前言在 Kubernetes 中，Pod 使用的资源最重要的是 CPU、内存和磁盘 IO，这些资源可以被分为可压缩资源（CPU）和不可压缩资源（内存，磁盘 IO）。可压缩资源不可能导致 Pod 被驱逐，因为当 Pod 的 CPU 使用量很多时，系统可以通过重新分配权重来限制 Pod 的 CPU 使用。而对于不可压缩资源来说，如果资源不足，也就无法继续申请资源（内存用完就是用完了），此时 Kubernetes 会从该节点上驱逐一定数量的 Pod，以保证该节点上有充足的资源。当不可压缩资源不足时，Kubernetes 是通过 kubelet 来驱逐 Pod 的。kubelet 也不是随机驱逐的，它有自己的一套驱逐机制，每个计算节点的 kubelet 都会通过抓取 cAdvisor 的指标来监控节点的资源使用量，下面我们来具体分析每种情况。 1. 存储资源不足下面是 kubelet 默认的关于节点存储的驱逐触发条件： nodefs.available&lt;10%（容器 volume 使用的文件系统的可用空间，包括文件系统剩余大小和 inode 数量） imagefs.available&lt;15%（容器镜像使用的文件系统的可用空间，包括文件系统剩余大小和 inode 数量） 当 imagefs 使用量达到阈值时，kubelet 会尝试删除不使用的镜像来清理磁盘空间。 当 nodefs 使用量达到阈值时，kubelet 就会拒绝在该节点上运行新 Pod，并向 API Server 注册一个 DiskPressure condition。然后 kubelet 会尝试删除死亡的 Pod 和容器来回收磁盘空间，如果此时 nodefs 使用量仍然没有低于阈值，kubelet 就会开始驱逐 Pod。从 Kubernetes 1.9 开始，kubelet 驱逐 Pod 的过程中不会参考 Pod 的 QoS，只是根据 Pod 的 nodefs 使用量来进行排名，并选取使用量最多的 Pod 进行驱逐。所以即使 QoS 等级为 Guaranteed 的 Pod 在这个阶段也有可能被驱逐（例如 nodefs 使用量最大）。如果驱逐的是 Daemonset，kubelet 会阻止该 Pod 重启，直到 nodefs 使用量超过阈值。 如果一个 Pod 中有多个容器，kubelet 会根据 Pod 中所有容器的 nodefs 使用量之和来进行排名。即所有容器的 container_fs_usage_bytes 指标值之和。 举个栗子，假设某计算节点上运行着一系列已知 QoS 等级和 nodefs 使用量的 Pod： Pod Name Pod QoS nodefs usage A Best Effort 800M B Guaranteed 1.3G C Burstable 1.2G D Burstable 700M E Best Effort 500M F Guaranteed 1G 当 nodefs 的使用量超过阈值时，kubelet 会根据 Pod 的 nodefs 使用量来对 Pod 进行排名，首先驱逐使用量最多的 Pod。排名如下图所示： Pod Name Pod QoS nodefs usage B Guaranteed 1.3G C Burstable 1.2G F Guaranteed 1G A Best Effort 800M D Burstable 700M E Best Effort 500M 可以看到在本例中，QoS 等级为 Guaranteed 的 Pod 最先被驱逐。 2. 内存资源不足下面是 kubelet 默认的关于节点内存资源的驱逐触发条件： memory.available&lt;100Mi 当内存使用量超过阈值时，kubelet 就会向 API Server 注册一个 MemoryPressure condition，此时 kubelet 不会接受新的 QoS 等级为 Best Effort 的 Pod 在该节点上运行，并按照以下顺序来驱逐 Pod： Pod 的内存使用量是否超过了 request 指定的值 根据 priority 排序，优先级低的 Pod 最先被驱逐 比较它们的内存使用量与 request 指定的值之差。 按照这个顺序，可以确保 QoS 等级为 Guaranteed 的 Pod 不会在 QoS 等级为 Best Effort 的 Pod 之前被驱逐，但不能保证它不会在 QoS 等级为 Burstable 的 Pod 之前被驱逐。 如果一个 Pod 中有多个容器，kubelet 会根据 Pod 中所有容器相对于 request 的内存使用量与之和来进行排名。即所有容器的 （container_memory_usage_bytes 指标值与 container_resource_requests_memory_bytes 指标值的差）之和。 继续举例，假设某计算节点上运行着一系列已知 QoS 等级和内存使用量的 Pod： Pod Name Pod QoS Memory requested Memory limits Memory usage A Best Effort 0 0 700M B Guaranteed 2Gi 2Gi 1.9G C Burstable 1Gi 2Gi 1.8G D Burstable 1Gi 2Gi 800M E Best Effort 0 0 300M F Guaranteed 2Gi 2Gi 1G 当节点的内存使用量超过阈值时，kubelet 会根据 Pod 相对于 request 的内存使用量来对 Pod 进行排名。排名如下所示： Pod Name Pod QoS Memory requested Memory limits Memory usage C Burstable 1Gi 2Gi 1.8G 800M A Best Effort 0 0 700M 700M E Best Effort 0 0 300M 300M B Guaranteed 2Gi 2Gi 1.9G -100M D Burstable 1Gi 2Gi 800M -200M F Guaranteed 2Gi 2Gi 1G -1G 可以看到在本例中，可以看到在本例中，QoS 等级为 Guaranteed 的 Pod 在 QoS 等级为 Burstable 的 Pod 之前被驱逐。 当内存资源不足时，kubelet 在驱逐 Pod 时只会考虑 requests 和 Pod 的内存使用量，不会考虑 limits。 3. Node OOM (Out Of Memory)因为 kubelet 默认每 10 秒抓取一次 cAdvisor 的监控数据，所以有可能在 kubelet 驱逐 Pod 回收内存之前发生内存使用量激增的情况，这时就有可能触发内核 OOM killer。这时删除容器的权利就由kubelet 转交到内核 OOM killer 手里，但 kubelet 仍然会起到一定的决定作用，它会根据 Pod 的 QoS 来设置其 oom_score_adj 值：QoS oom_score_adjGuaranteed -998Burstable min(max(2, 1000 - (1000 * memoryRequestBytes) / machineMemoryCapacityBytes), 999)pod-infra-container -998kubelet, docker daemon, systemd service -999如果该节点在 kubelet 通过驱逐 Pod 回收内存之前触发了 OOM 事件，OOM killer 就会采取行动来降低系统的压力，它会根据下面的公式来计算 oom_score 的值： 容器使用的内存占系统内存的百分比 + oom_score_adj = oom_score OOM killer 会杀掉 oom_score_adj 值最高的容器，如果有多个容器的 oom_score_adj 值相同，就会杀掉内存使用量最多的容器（其实是因为内存使用量最多的容器的 oom_score 值最高）。关于 OOM 的更多内容请参考：Kubernetes 内存资源限制实战。 假设某节点运行着 4 个 Pod，且每个 Pod 中只有一个容器。每个 QoS 类型为 Burstable 的 Pod 配置的内存 requests 是 4Gi，节点的内存大小为 30Gi。每个 Pod 的 oom_score_adj 值如下所示： Pod Name Pod QoS oom_score_adj A Best Effort 1000 B Guaranteed -998 C Burstable 867（根据上面的公式计算） D Best Effort 1000 当调用 OOM killer 时，它首先选择 oom_score_adj 值最高的容器（1000），这里有两个容器的 oom_score_adj 值都是 1000，OOM killer 最终会选择内存使用量最多的容器。 总结因为 kubelet 默认每 10 秒抓取一次 cAdvisor 的监控数据，所以可能在资源使用量低于阈值时，kubelet 仍然在驱逐 Pod。 kubelet 将 Pod 从节点上驱逐之后，Kubernetes 会将该 Pod 重新调度到另一个资源充足的节点上。但有时候 Scheduler 会将该 Pod 重新调度到与之前相同的节点上，比如设置了节点亲和性，或者该 Pod 以 Daemonset 的形式运行。 现在你应该理解了 kubelet 驱逐 Pod 的原理和过程，如果你在部署应用时设置了恰当的参数，知道了所有的可能性，你就能更好地掌控你的集群。","tags":[{"name":"k8s","slug":"k8s","permalink":"http://maxzhang1985.github.io/tags/k8s/"}]},{"title":"ASP.NET Core中结合枚举和资源文件显示列表","date":"2020-05-11T16:37:10.000Z","path":"2020/05/11/aspnetcore-displaying-enumwhithrec/","text":"前言模型类的某些属性以枚举形式出现，我们希望在打开编辑表单时在选择列表中显示枚举值。有时我们想要枚举元素名称，但有时我们想要使用自定义名称甚至翻译。这个例子演示了如何获取枚举元素名称以选择ASP.NET Core上的列表。 假设我们有一个客户实体，其客户类型属性定义为枚举。123456public class Customer&#123; public Guid Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public CustomerTypeEnum Type &#123; get; set; &#125;&#125; 定义枚举并使其使用DisplayAttribute指定资源文件。 12345678910public enum CustomerTypeEnum&#123; [Display(Name = \"Companies\")] PrivateSector, [Display(Name = \"PublicSector\", ResourceType = typeof(Resources.Common))] PublicSector, Internal&#125; 例子中共有三种不同的情况： 枚举成员仅一个名字 具有Display属性和静态名称的Enum成员 具有显示属性和资源文件的枚举成员 我的资源文件在这里。 重要事项：将资源修饰符设置为“公共”（当资源窗口足够宽时，此选项才可见）。 现在添加了一个简单的编辑视图，并使用Html.GetEnumSelectList()扩展方法来填充带有enum成员的选择列表。注意我如何添加第一个空选择(选择类型)作为选择列表的唯一成员。 123456789101112131415161718192021222324252627282930313233343536@model Customer@&#123; ViewData[\"Title\"] = \"Edit\";&#125; &lt;h1&gt;Edit&lt;/h1&gt; &lt;form asp-action=\"Edit\" class=\"row\"&gt; &lt;div class=\"col-4\"&gt; &lt;div asp-validation-summary=\"All\" class=\"text-danger\"&gt;&lt;/div&gt; &lt;input type=\"hidden\" asp-for=\"Id\" /&gt; &lt;div class=\"form-group\"&gt; &lt;label asp-for=\"Name\" class=\"control-label\"&gt;&lt;/label&gt; &lt;input asp-for=\"Name\" class=\"form-control\" /&gt; &lt;span asp-validation-for=\"Name\" class=\"text-danger\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label asp-for=\"Type\" class=\"control-label\"&gt;&lt;/label&gt; &lt;select asp-for=\"Type\" class=\"form-control\" asp-items=\"Html.GetEnumSelectList&lt;CustomerTypeEnum&gt;()\"&gt; &lt;option&gt;Select type ...&lt;/option&gt; &lt;/select&gt; &lt;span asp-validation-for=\"Type\" class=\"text-danger\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"submit\" value=\"Save\" class=\"btn btn-primary\" /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; &lt;div&gt; &lt;a asp-action=\"Index\"&gt;Back to List&lt;/a&gt;&lt;/div&gt; 当运行应用程序并移至编辑表单时，可以看到选择列表填充了枚举成员，并且ASP.NET Core带有名称和资源文件的DisplayAttribute。 推广GitHub：https://github.com/maxzhang1985/yoyogo 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[]},{"title":"记一次JAVA进程导致Kubernetes节点CPU飙高的排查与解决","date":"2020-04-10T12:54:32.000Z","path":"2020/04/10/k8s-jvm-hicpu-problem/","text":"一、发现问题在一次系统上线后，我们发现某几个节点在长时间运行后会出现CPU持续飙升的问题，导致的结果就是Kubernetes集群的这个节点会把所在的Pod进行驱逐（调度）；如果调度到同样问题的节点上，也会出现Pod一直起不来的问题。我们尝试了杀死Pod后手动调度的办法（label），当然也可以排除调度节点。但是在一段时间后还会复现，我们通过监控系统也排查了这段时间的流量情况，但应该和CPU持续占用没有关联，这时我们意识到这可能是程序的问题。 二、排查问题定位Pod这里使用kubectl top pods 命令确定CPU占用最高的pods都是哪些。1kubectl -n app top pods 因为问题已解决，以上图片只是举个例子。 排查工具Arthas我们这边使用了阿里的Arthas ，它是Alibaba开源的Java诊断工具。当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 排查问题定位到有问题的Pod后,使用kubectl exec进入Pod容器内部：1kubectl -n app exec -it 49a89b2f-73c6-40ac-b6de-c6d0e47ace64-5d489d9c48qwc7t -- /bin/bash 在容器中下载Arthas1wget https://arthas.gitee.io/arthas-boot.jar 由于我们打包镜像中只有一个服务，所以一个Pod中也只有一个进程； 这里 1 是指PID。1java -jar arthas-boot.jar 1 执行进程看板 dashboard：1[arthas@1]$ dashboard 这里上半区显示了线程内容，我们可以看到哪个线程ID的对应情况： 比如从上面得到了线程ID，使用如下命令进入线程，如ID 12262：1[arthas@1]$ thread -n 12262 打印出线程日志：123456789101112[arthas@1]$ thread -n 12262&quot;com.alibaba.nacos.client.Worker.addr-bj-internal.edas.aliyun.com-7362814c-538b-4c26-aa07-1fd47765a145&quot; Id=20190 cpuUsage=7% TIMED_WAITING on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@d30d0a4e (in native) at sun.misc.Unsafe.park(Native Method) - waiting on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@d30d0a4e at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078) at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093) at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:813) 三、解决问题经过了排查定位到了问题，最后经过社区和阿里云伙伴的协助，发现了这个是Nacos 2.0.0.RELEASE的一个BUG。我们对Nacos客户端版本进行了升级，经过测试后，问题解决了。也加深了对Kubernetes集群调试的能力 [加油]。 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 四、最后通过社区和阿里云的帮助，问题成功解决。在工具方面，阿里提供的Arthas，真的是线上环境调试神器！","tags":[{"name":"k8s jvm","slug":"k8s-jvm","permalink":"http://maxzhang1985.github.io/tags/k8s-jvm/"}]},{"title":".NET Core 3.0 Assembly Unload","date":"2019-05-16T11:11:16.000Z","path":"2019/05/16/netcore3-assemly-unload/","text":"一、前言.NET诞生以来，程序集的动态加载和卸载都是一个Hack的技术，之前的NetFx都是使用AppDomain的方式去加载程序集，然而AppDomain并没有提供直接卸载一个程序集的API，而是要卸载整个AppDomain才能卸载包含在其中的所有程序集。然而卸载整个CurrentAppDomain会使程序不能工作。可能有人另辟西经，创建别一个AppDomain来加载/卸载程序集，但是由于程序集之间是不能跨域访问的，也导致只能通过Remote Proxy的方式去访问，这样在类型创建和使用上带来了一定的难度也是类型的继承变得相当复杂。 .NET Core中一直没有AppDomain的支持。但是在.NET Core 3.0中，我最期待的一个特性就是对可收集程序集的支持(Collectible AssemblyLoadContext)。 众所周知.NET Core中一直使用AssemblyLoadContext的API，来进行程序集的动态加载，但是并没有提供Unload的方法，此次升级更新了这方面的能力。 二、AssemblyLoadContext其实这次AssemblyLoadContext的设计，我认为更像是Java中ClassLoader的翻版，可以说非常类似。在使用过程中自定义AssemblyLoadContext可以内部管理其中的程序集，并对整体Context进行Unload。使用AssemblyLoadContext也可以避免程序集名称和版本的冲突。 三、Getting Started.NET Core 3.0还没有正式版，所有要使用预览版的SDK完成以下实例。我使用的是.NET Core SDK 3.0.100-preview-0098121dotnet new globaljson --sdk-version 3.0.100-preview-009812 AssemblyLoadContext是一个抽象类的，我们需要子类化。下面显示的是我们创建自定义AssemblyLoadContext的方法,实现一个可回收的Context需要在构造器中指定isCollectible: true ：12345678910public class CollectibleAssemblyLoadContext : AssemblyLoadContext&#123; public CollectibleAssemblyLoadContext() : base(isCollectible: true) &#123; &#125; protected override Assembly Load(AssemblyName assemblyName) &#123; return null; &#125;&#125; 使用netstandard2.0创建一个library123456789101112using System; namespace SampleLibrary&#123; public class SayHello &#123; public void Hello(int iteration) &#123; Console.WriteLine($\"Hello &#123;iteration&#125;!\"); &#125; &#125;&#125; 测试Load/Unload1234567891011121314151617var context = new CollectibleAssemblyLoadContext();var assemblyPath = Path.Combine(Directory.GetCurrentDirectory(),\"SampleLibrary.dll\");using (var fs = new FileStream(assemblyPath, FileMode.Open, FileAccess.Read))&#123; var assembly = context.LoadFromStream(fs); var type = assembly.GetType(\"SampleLibrary.SayHello\"); var greetMethod = type.GetMethod(\"Hello\"); var instance = Activator.CreateInstance(type); greetMethod.Invoke(instance, new object[] &#123; i &#125;);&#125;context.Unload();GC.Collect();GC.WaitForPendingFinalizers(); 当执行GC收回后，加载的程序集会被完全的回收。 三、最后 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://maxzhang1985.github.io/tags/dotnet/"}]},{"title":"ASP.NET Core MVC全局应用ApiController特性","date":"2019-04-04T11:30:32.000Z","path":"2019/04/04/aspnetcore2-mvc-apicontoller/","text":"一、前言因为在ASP.NET Core 2中，ApiController与Controller得到了统一的编程模型，都继承自Controller类。ASP.NET Core MVC 2.1中加入了[ApiController]特性，用于标示某个控制器为API控制器。 二、特性[ApiController] 使得我们不再需要手动标示参数的[FormBody] 就能获取到来自HTTP请求来的JSON数据，和模型验证，这一切都会自动的发生。 三、全局设置这里说是全局，但是MVC提供的方案是针对Assembly级别的。设置下如：1234567[assembly: ApiController]namespace MyNamespace&#123; public class Startup &#123; &#125;&#125; 四、最后 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"dotnet aspnet","slug":"dotnet-aspnet","permalink":"http://maxzhang1985.github.io/tags/dotnet-aspnet/"}]},{"title":"Prometheus AlertManager (服务报警中心)","date":"2018-12-05T19:07:44.000Z","path":"2018/12/05/alertmanager/","text":"Prometheus Alert 简介Prometheus（普罗米修斯）是一个开源系统监控和警报工具，最初是在SoundCloud建立的。自2012年成立以来，许多公司和组织都采用了普罗米修斯，该项目拥有一个非常活跃的开发者和用户社区。它现在是一个独立的开放源码项目，并且独立于任何公司。为了强调这一点，为了澄清项目的治理结构，普罗米修斯在2016年加入了云计算基金会，成为继Kubernetes之后的第二个托管项目。AlertMananger是它的独立报警模块. 一、安装1.下载alertManager组件https://prometheus.io/download/ 解压tar包即可。 2.发送邮件配置：(alert.yml)12345678910111213141516171819202122232425262728293031323334global: smtp_smarthost: 'smtp.163.com:25' #163服务器 smtp_from: '000@163.com' #发邮件的邮箱 smtp_auth_username: '000@163.com' #发邮件的邮箱用户名，也就是你的邮箱 smtp_auth_password: '000' #邮箱的授权密码 (如果是163邮箱，需要在设置-&gt;常规设置-&gt;点击左侧的客户端授权密码-&gt;开启授权密码)templates:- '/etc/alertmanager/template/*.tmpl' #加载所有消息通知模板route: receiver: 'default-receiver' group_by: ['alertname','cluster'] #将传入警报分组在一起的标签。例如，cluster=A和alertname=LatencyHigh的多个警报将批处理为单个组。 group_wait：30s #当传入的警报创建新的警报组时，至少等待\"30s\"发送初始通知。 group_interval：5m #当发送第一个通知时，等待\"5m\"发送一批新的警报，这些警报开始针对该组触发。 （如果是group_by里的内容为新的如：alertname=1,alertname=2 会马上发送2封邮件, 如果是group_by之外的会等待5m触发一次） repeat_interval: 4h #如果警报已成功发送，请等待\"4h\"重新发送，重复发送邮件的时间间隔 routes: #所有与下列子路由不匹配的警报将保留在根节点，并被分派到'default-receiver'。 - receiver: 'database-pager' group_wait: 10s match_re: service: mysql|cassandra #带有service=mysql或service=cassandra的所有警报都被发送到'database-pager' - receiver: 'frontend-pager' group_by: [product, environment] match: team: frontend #team=frontend的 和receivers:- name: default-receiver #不同的报警 发送给不同的邮箱 email_configs: - to: '475132489@qq.com,44646@qq.com' #收邮件的邮箱 多个邮箱用,隔开 html: '&#123;&#123; template \"default.html\" . &#125;&#125;' #应用哪个模板 headers: &#123; Subject: \"[WARN] 报警邮件default\" &#125; #邮件头信息- name: database-pager email_configs: - to: '2312123@qq.com' html: '&#123;&#123; template \"database.html\" . &#125;&#125;' #应用哪个模板 headers: &#123; Subject: \"[INFO] 报警邮件test\" &#125; #邮件头信息 3.配置模板AlertManager用的模板系统中使用的变量如下： 变量 类型 说明 Receiver String 通知将被发送到的接收者名称 Status String 报警状态 firing resolved Alerts Alert 警报对象列表 GroupLabels KV 警报的标签分组 CommonLabels KV 警报共有的标签 CommonAnnotations KV 警报的常用注释 ExternalURL String 链接到发送通知的Alertmanager Alert Alert 警报对象列表 Status String 定义警报是否已解决 Labels KV 警报的一组标签 Annotations KV 警报的一组注释 StartsAt time 开始时间 EndsAt time 结束时间 GeneratorURL String 一个反向链接，用于标识此警报的生成实体 配置方法如下：alert.yml文件配置加载目录下的模板：12templates: - '/etc/alertmanager-0.15.3/template/*.tmpl' 配置模板内容在程序根目录下的template下，建立alertemp.tmpl模板文件内容如下：123456789101112131415161718&#123;&#123; define \"email.default.subject\" &#125;&#125; #邮件主题模板 [错误订阅信息]&#123;&#123; len .Alerts &#125;&#125;条 (&#123;&#123;.GroupLabels.appid&#125;&#125;-&#123;&#123;.GroupLabels.service&#125;&#125;) 时间 &#123;&#123; range $i, $alert := .Alerts &#125;&#125; &#123;&#123;if eq $i 0&#125;&#125; &#123;&#123; $alert.StartsAt &#125;&#125; &#123;&#123; end &#125;&#125; &#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125; &#123;&#123; define \"alertemp.html\" &#125;&#125; #邮件内容模板 alertemp.html为模板名称&lt;table&gt; #模板内容 格式为html &lt;tr&gt;&lt;td&gt;报警名称&lt;/td&gt;&lt;td&gt;开始时间&lt;/td&gt;&lt;/tr&gt; &#123;&#123; range $i, $alert := .Alerts &#125;&#125; #遍历Alerts &lt;tr&gt;&lt;td&gt;&#123;&#123; $alert.Labels.alertname &#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123; $alert.StartsAt &#125;&#125;&lt;/td&gt;&lt;/tr&gt; #取值时Labels,StartsAt等严格按照 官方文档定义字段取值 否则取不到 &lt;span style=\"font-size:18px;font-weight: 600;\" &gt;错误信息: &lt;/span&gt;&lt;span style=\"font-size:15px;\"&gt;&#123;&#123; $alert.Annotations.errormessage &#125;&#125;&lt;/span&gt;&lt;br/&gt; &#123;&#123; end &#125;&#125;&lt;/table&gt;&#123;&#123; end &#125;&#125; 指定接收者和模板格式123456receivers:- name: default-receiver email_configs: - to: '475132489@qq.com' #收邮件的邮箱 html: '&#123;&#123; template \"alertemp.html\" . &#125;&#125;' #应用哪个模板 headers: &#123; Subject: \"[WARN] 报警邮件alertemp\" &#125; #邮件主题信息 如果不写headers也可以在模板中定义默认加载email.default.subject这个模板 二.启动与测试1./alertmanager -config.file=alert.yml 模拟请求触发报警：测试地址1http://localhost:9093/api/v1/alerts POST数据12345678910[&#123; \"labels\": &#123; \"alertname\": \"alertname\", \"severity\": \"warning\" &#125;, \"annotations\": &#123; \"description\": \"Instance play-app:9000 under lower load\", \"summary\": \"play-app:9000 of job playframework-app is under lower load\" &#125;&#125;] 总结：1.不同报警发送不同的邮箱，每个邮箱的模板都可以自定义。2.appId，service，title 都相同的报警信息，一定时间内汇总到一封邮件内。3.alertmanager post请求 ip:9093/-/reload 完成配置文件的热加载。","tags":[{"name":"Architecture","slug":"Architecture","permalink":"http://maxzhang1985.github.io/tags/Architecture/"}]},{"title":"Spring Boot使用Logback通过Kafka实现日志收集","date":"2018-08-23T10:18:34.000Z","path":"2018/08/23/springboot-logback-kafka/","text":"前言承接上文.NET/Core的实现,我们的目地是为了让微服务环境中dotnet和java的服务都统一的进行日志收集。Java体系下Spring Boot + Logback很容易就接入了Kafka实现了日志收集。 Spring Boot集成Maven 包管理123456789&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 包依赖引用:12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.github.danielwegener&lt;/groupId&gt; &lt;artifactId&gt;logback-kafka-appender&lt;/artifactId&gt; &lt;version&gt;0.2.0-RC1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt; &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt; &lt;version&gt;5.0&lt;/version&gt;&lt;/dependency&gt; logback-spring.xml在Spring Boot项目resources目录下添加logback-spring.xml配置文件，注意：一定要修改 {“appname”:”webdemo”}，这个值也可以在配置中设置为变量。添加如下配置，STDOUT是在连接失败时，使用的日志输出配置。所以这每个项目要根据自己的情况添加配置。在普通日志输出中使用异步策略提高性能，内容如下:123456789101112131415161718192021222324&lt;appender name=\"kafkaAppender\" class=\"com.github.danielwegener.logback.kafka.KafkaAppender\"&gt; &lt;encoder charset=\"UTF-8\" class=\"net.logstash.logback.encoder.LogstashEncoder\" &gt; &lt;customFields&gt;&#123;\"appname\":\"webdemo\"&#125;&lt;/customFields&gt; &lt;includeMdc&gt;true&lt;/includeMdc&gt; &lt;includeContext&gt;true&lt;/includeContext&gt; &lt;throwableConverter class=\"net.logstash.logback.stacktrace.ShortenedThrowableConverter\"&gt; &lt;maxDepthPerThrowable&gt;30&lt;/maxDepthPerThrowable&gt; &lt;rootCauseFirst&gt;true&lt;/rootCauseFirst&gt; &lt;/throwableConverter&gt; &lt;/encoder&gt; &lt;topic&gt;loges&lt;/topic&gt; &lt;keyingStrategy class=\"com.github.danielwegener.logback.kafka.keying.HostNameKeyingStrategy\" /&gt; &lt;deliveryStrategy class=\"com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy\" /&gt; &lt;producerConfig&gt;bootstrap.servers=127.0.0.1:9092&lt;/producerConfig&gt; &lt;!-- don't wait for a broker to ack the reception of a batch. --&gt; &lt;producerConfig&gt;acks=0&lt;/producerConfig&gt; &lt;!-- wait up to 1000ms and collect log messages before sending them as a batch --&gt; &lt;producerConfig&gt;linger.ms=1000&lt;/producerConfig&gt; &lt;!-- even if the producer buffer runs full, do not block the application but start to drop messages --&gt; &lt;!--&lt;producerConfig&gt;max.block.ms=0&lt;/producerConfig&gt;--&gt; &lt;producerConfig&gt;block.on.buffer.full=false&lt;/producerConfig&gt; &lt;!-- kafka连接失败后，使用下面配置进行日志输出 --&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/appender&gt; 注意：一定要修改 {“appname”:”webdemo”} ， 这个值也可以在配置中设置为变量 。对于第三方框架或库的错误和异常信息如需要写入日志,错误配置如下：12345678910111213141516171819202122232425262728293031&lt;appender name=\"kafkaAppenderERROR\" class=\"com.github.danielwegener.logback.kafka.KafkaAppender\"&gt; &lt;encoder charset=\"UTF-8\" class=\"net.logstash.logback.encoder.LogstashEncoder\" &gt; &lt;customFields&gt;&#123;\"appname\":\"webdemo\"&#125;&lt;/customFields&gt; &lt;includeMdc&gt;true&lt;/includeMdc&gt; &lt;includeContext&gt;true&lt;/includeContext&gt; &lt;throwableConverter class=\"net.logstash.logback.stacktrace.ShortenedThrowableConverter\"&gt; &lt;maxDepthPerThrowable&gt;30&lt;/maxDepthPerThrowable&gt; &lt;rootCauseFirst&gt;true&lt;/rootCauseFirst&gt; &lt;/throwableConverter&gt; &lt;/encoder&gt; &lt;topic&gt;ep_component_log&lt;/topic&gt; &lt;keyingStrategy class=\"com.github.danielwegener.logback.kafka.keying.HostNameKeyingStrategy\" /&gt; &lt;deliveryStrategy class=\"com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy\" /&gt; &lt;deliveryStrategy class=\"com.github.danielwegener.logback.kafka.delivery.BlockingDeliveryStrategy\"&gt; &lt;!-- wait indefinitely until the kafka producer was able to send the message --&gt; &lt;timeout&gt;0&lt;/timeout&gt; &lt;/deliveryStrategy&gt; &lt;producerConfig&gt;bootstrap.servers=127.0.0.1:9020&lt;/producerConfig&gt; &lt;!-- don't wait for a broker to ack the reception of a batch. --&gt; &lt;producerConfig&gt;acks=0&lt;/producerConfig&gt; &lt;!-- wait up to 1000ms and collect log messages before sending them as a batch --&gt; &lt;producerConfig&gt;linger.ms=1000&lt;/producerConfig&gt; &lt;!-- even if the producer buffer runs full, do not block the application but start to drop messages --&gt; &lt;producerConfig&gt;max.block.ms=0&lt;/producerConfig&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt;&lt;!-- 只打印错误日志 --&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; 在异常日志用使用了同步策略保证，错误日志的有效收集，当然可以根据实际项目情况进行配置。 LOG配置建议：日志root指定错误即可输出第三方框架异常日志:123&lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"kafkaAppenderERROR\" /&gt;&lt;/root&gt; 建议只输出自己程序里的级别日志配置如下（只供参考）： 1234&lt;logger name=\"项目所在包\" additivity=\"false\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;appender-ref ref=\"kafkaAppender\" /&gt;&lt;/logger&gt; 最后GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"java springboot","slug":"java-springboot","permalink":"http://maxzhang1985.github.io/tags/java-springboot/"}]},{"title":".NET Core使用NLog通过Kafka实现日志收集","date":"2018-08-16T13:09:14.000Z","path":"2018/08/16/netcore2-nlog-kafka/","text":"一、前言NET Core越来越受欢迎，因为它具有在多个平台上运行的原始.NET Framework的强大功能。Kafka正迅速成为软件行业的标准消息传递技术。这篇文章简单介绍了如何使用.NET(Core)和Kafka实现NLog的Target。 在日常项目开发过程中，Java体系下Spring Boot + Logback很容易就接入了Kafka实现了日志收集，在.NET和.NET Core下一直习惯了使用NLog作为日志组件。为了让微服务环境中dotnet和java的服务都统一的进行日志收集，接下来的文章中会介绍两种语言的统一接入方式。写这个组件的目地是让团队成员不需要编写NLog的JsonLayout从而达到与java服务输出一样格式到kafka的目地，简化开发人员的配置难度，当然代价就是配置不灵活了。 二、开源通过实现NLog的Target，接入kafka将日志传输到Logstash的组件。 https://github.com/maxzhang1985/NLog.Kafka 三、使用建立项目NLog.Kafka组件支持.NET 4.5+和 NETStandard1.6+ ,所在可以在传统.NET使用，当然也支持.NET Core的跨平台使用(Win、Linux、Mac)。 项目引用 NLog 4.5.8 NLog.Kafka librdkafka.redist 引用librdkafka.redist是因为使用了依赖库Confluent.Kafka 0.11.5,Confluent.Kafka 使用了著名的librdkafka开源库，它是用C ++编写的，作为其它的语言（如C ++，C＃，Python和Node）的Kafka驱动程序的基础。 配置在项目中建立NLog.config，并设置为Copy always，内容如下：123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!--nlog 基础配置 第二行throwExceptions开始 上线后关闭--&gt;&lt;nlog autoReload=\"true\" xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" throwExceptions=\"true\" throwConfigExceptions=\"true\" internalLogLevel=\"Trace\" &gt; &lt;!-- load NLog.Extended to enable ASP.NET-specific functionality --&gt; &lt;targets&gt; &lt;target name=\"queue\" xsi:type=\"kafka\" topic=\"ep_component_log\" appname=\"nlogtest\" includeMdc=\"true\" &gt; &lt;!-- bootstrap.servers = 127.0.0.1:9092,127.0.0.1:9092,127.0.0.1:9092 --&gt; &lt;producerConfig key=\"bootstrap.servers\" value=\"127.0.0.1:9092\" /&gt; &lt;producerConfig key=\"queue.buffering.max.messages\" value=\"2000000\" /&gt; &lt;producerConfig key=\"retry.backoff.ms\" value=\"500\" /&gt; &lt;producerConfig key=\"message.send.max.retries\" value=\"3\" /&gt; &lt;/target&gt; &lt;/targets&gt; &lt;rules&gt; &lt;logger name=\"*\" writeTo=\"queue\" /&gt; &lt;/rules&gt;&lt;/nlog&gt; 编写测试代码1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; Logger logger = LogManager.GetCurrentClassLogger(); MappedDiagnosticsContext.Set(\"item1\", \"haha\"); for(int i = 0; i &lt; 10; i++) &#123; logger.Info(\"hello world\"); Console.WriteLine(\"sended\"); &#125; Console.ReadKey(); &#125;&#125; 四、最后附上的Demo和开源库地址：https://github.com/maxzhang1985/NLog.Kafka GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"dotnet kafka nlog","slug":"dotnet-kafka-nlog","permalink":"http://maxzhang1985.github.io/tags/dotnet-kafka-nlog/"}]},{"title":"ASP.NET Core使用SkiaSharp实现验证码","date":"2017-12-28T17:49:27.000Z","path":"2017/12/28/ASPNETCore-Captcha-Skia/","text":"前言本文并没有实现一个完成的验证码样例，只是提供了在当前.NET Core 2.0下使用Drawing API的另一种思路，并以简单Demo的形式展示出来。 SkiaSkia是一个开源的二维图形库，提供各种常用的API，并可在多种软硬件平台上运行。谷歌Chrome浏览器、Chrome OS、安卓、火狐浏览器、火狐操作系统以及其它许多产品都使用它作为图形引擎。 Skia由谷歌出资管理，任何人都可基于BSD免费软件许可证使用Skia。Skia开发团队致力于开发其核心部分， 并广泛采纳各方对于Skia的开源贡献。 SkiaSharpSkiaSharp是由Mono发起,基于谷歌的Skia图形库,实现的一个跨平台的2D图形.NET API绑定。提供一个全面的2D API，可用于跨移动、服务器和桌面模式的图形渲染和图像处理。 skiasharp提供PCL和平台特定的绑定： .NET Core / .NET Standard 1.3 Xamarin.Android Xamarin.iOS Xamarin.tvOS Xamarin.Mac Windows Classic Desktop (Windows.Forms / WPF) Windows UWP (Desktop / Mobile / Xbox / HoloLens) 使用SkiaSharp1dotnet add package SkiaSharp --version 1.59.3 ASP.NET验证码?前使用SkiaSharp实现文本绘图功能，代码如下：12345678910111213141516171819202122232425262728293031323334353637internal static byte[] GetCaptcha(string captchaText) &#123; byte[] imageBytes = null; int image2d_x = 0; int image2d_y = 0; SKRect size; int compensateDeepCharacters = 0; using (SKPaint drawStyle = CreatePaint()) &#123; compensateDeepCharacters = (int)drawStyle.TextSize / 5; if (System.StringComparer.Ordinal.Equals(captchaText, captchaText.ToUpperInvariant())) compensateDeepCharacters = 0; size = SkiaHelpers.MeasureText(captchaText, drawStyle); image2d_x = (int)size.Width + 10; image2d_y = (int)size.Height + 10 + compensateDeepCharacters; &#125; using (SKBitmap image2d = new SKBitmap(image2d_x, image2d_y, SKColorType.Bgra8888, SKAlphaType.Premul)) &#123; using (SKCanvas canvas = new SKCanvas(image2d)) &#123; canvas.DrawColor(SKColors.Black); // Clear using (SKPaint drawStyle = CreatePaint()) &#123; canvas.DrawText(captchaText, 0 + 5, image2d_y - 5 - compensateDeepCharacters, drawStyle); &#125; using (SKImage img = SKImage.FromBitmap(image2d)) &#123; using (SKData p = img.Encode(SKEncodedImageFormat.Png, 100)) &#123; imageBytes = p.ToArray(); &#125; &#125; &#125; &#125; return imageBytes; &#125; ASP.NET Core输出图像：123456[HttpGet(\"/api/captcha\")]public IActionResult Captcha()&#123; var bytes = SkiaCaptcha.Captcha.GetCaptcha(\"hello world\"); return File(bytes, \"image/png\");&#125; 参考https://skia.org/index_zh https://github.com/mono/SkiaSharp https://developer.xamarin.com/api/namespace/SkiaSharp/ demo地址https://github.com/maxzhang1985/ASPNETCore_Captcha_Skia GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"dotnet aspnet","slug":"dotnet-aspnet","permalink":"http://maxzhang1985.github.io/tags/dotnet-aspnet/"}]},{"title":"VS Code在WSL中调试.NET Core应用程序","date":"2017-12-07T20:36:36.000Z","path":"2017/12/07/vscode-debug-dotnetcore-wsl/","text":"前言在前几个Visual Studio Code更新中发现有一个重要得特性，就是nodejs可以使用VS Code在WSL中进行Debug了（WSL是指Win10中的Linux子系统）,之前写过一篇文章是使用SSH对Linux环境进行Debug，此时的想法就是如果可以在WSL中直接对程序进行调试的话，那么对于开发人员这项功能将是在Windows中最好连接Linux环境的开发环境了，而且由于Windows子系统的“原理”，所有子系统中的进程将与系统进程运行在物理主机上，所以可以断定调试的“速度”也是非常快速的。 先决条件要想在Visual Studio Code中调试.NET Core程序，并运行在Windows Subsystem for linux(WSL)中，需要一些先决条件，这些条件包括： 需要将Windows更新到最新的创新者版本(版本号为：1709) 在WSL中安装.NET CORE SDK (2.0.2) 最新版本的VS Code和C#扩展 (Microsoft C# extension) 之所以要更新Windows系统到最新的创新者版本，主要是因为之前版本的Windows不能安装Ubuntu子系统的最新版本。之前的版本为14.04，要想使用新的特性，我们要将Ubuntu子系统升级到16.04版本。 解决问题安装WSL接下来我们先使用bash命令，确定一下Windows上安装的Ubuntu子系统的版本：12345~$ cat /etc/os-release | grep -i versionVERSION=\"16.04.2 LTS (Xenial Xerus)\"VERSION_ID=\"16.04\"VERSION_CODENAME=xenial 但是如果已经安装过WSL后再升级Windows，那样Ubuntu子秕的版本还会是14.04，所以需要重新安装一下Ubuntu子系统，命令如下：12lxrun /uninstall /fulllxrun /install 如果你已经是最新版本的创新者的Windows，此时Ubuntu子系统的版本也将升级到16.04。 安装.NET CORE SDK只需要到https://www.microsoft.com/net/core#linuxubuntu上找到，对应16.04版本安装方式，就可以顺利的安装了，与Ubuntu系统的真机安装体验一致。 安装调试器先要将调试器下载到子系统中运行bash,再运行如下命令：12sudo apt-get install unzipcurl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l ~/vsdbg 下载过程可能会很慢长，主要取决于是否FQ。下载后的文件会在当前目录的~/vsdbg/vsdbg。我的下载目录为:/home/maxzhang/vsdbg/vsdbg launch.json添加调试启动的配置：12345678910111213141516171819&#123; \"name\": \".NET Core WSL Launch\", \"type\": \"coreclr\", \"request\": \"launch\", \"preLaunchTask\": \"build\", \"program\": \"/mnt/f/dotnetcoreapps/DebugOnWSL/DebugOnWSL/bin/Debug/netcoreapp2.0/DebugOnWSL.dll\", \"args\": [], \"cwd\": \"/mnt/f/dotnetcoreapps/DebugOnWSL/DebugOnWSL\", \"stopAtEntry\": false, \"console\": \"internalConsole\", \"pipeTransport\": &#123; \"pipeCwd\": \"\", \"pipeProgram\": \"C:\\\\Windows\\\\System32\\\\bash.exe\", \"pipeArgs\": [ \"-c\" ], \"debuggerPath\": \"/home/maxzhang/vsdbg/vsdbg\" &#125;&#125; 具体路径需要按自己的需要进行修改，然后就可以按F5进行调试了。","tags":[{"name":"dotnet aspnet","slug":"dotnet-aspnet","permalink":"http://maxzhang1985.github.io/tags/dotnet-aspnet/"}]},{"title":".NET Core GC 模式分析","date":"2017-11-14T11:56:12.000Z","path":"2017/11/14/aspnetcore-gc-analysis/","text":"引出问题: Asp.net core应用在 Kubernetes上内存使用率过高问题分析https://mp.weixin.qq.com/s/PqhUzvFpzopU7rVRgdy7eg 这篇文章中讨论了，在默认情况下，ASP.NET Core程序跑在K8s的Docker中内存使用率&gt;=600MB，导致Docker容器频繁重启。并探讨并做了将ASP.NET Core项目配置System.GC.Server设置为False后，内存小于&lt;=150MB的实验。这文主要讲下什么是System.GC.Server，还有GC的二种模式。 对GC工作模式的分类:.NET Core 两种GC模式:Server GC / Workstation GC Server GC :主要应用于多处理器系统，并且作为ASP.NET Core宿主的默认配置。它会为每个处理器都创建一个GC Heap,并且会并行执行回收操作。该模式的GC可以最大化吞吐量和较好的收缩性。这种模式的特点是初始分配的内存较大，并且尽可能不回收内存,进行回收用时会很耗时,并进行内存碎片整理工作。 Workstation GC :主要应用于单处理器系统，Workstation GC尽可能地通过减少垃圾回收过程中程序的暂停次数来提高性能。低负载且不常在后台（如服务）执行任务的应用程序，可以在禁用并发垃圾回收的情况下使用工作站垃圾回收。特点是会频繁回收，来阻止一次较长时间的回收。 Concurrent GC 工作方式 :是一种GC的工作方式,如果你是单处理器的机器，那么即便配置了Concurrent选项为True，也不会生效。Server GC 和Workstation GC都可以开启Concurrent GC，在GC回收的过程中大部分时间用户线程可以并发运行。但只能影响到2代对象GC的过程，因为0代1代的时间太短了。 5.ASP.NET Core Project GC配置:ASP.NET CORE项目中，通过System.GC.Server配置进行GC模式设置,创建项目默认的GC模式是: System.GC.Server : true (Server GC Concurrent Mode) 每CPU分配GC ；System.GC.Server : false (Workstation GC Concurrent mode),且Concurrent=1。 GC 内存分配原则：GC heap用于保存0、1、2代的对象时，需要向系统申请时的基本单位是Segment，系统会分配指定值大小的Segment用于存储对象，这些值会随着程序的实际执行情况，由GC动态调整。正是由于有Segment的概念所以回出现内存碎片的问题，所以GC在垃圾回收过程中会进行内存整理，以减少内存碎片提高内存使用率。 Segment的大小取决于系统是32位还是64位，以及它正在运行的垃圾收集器的类型，下表列出了分配时系统所使用的默认值： GC Model 32-bit 64-bit Workstation GC 16 MB 256 MB Server GC 64 MB 4 GB Server GC with &gt; 4 logical CPUs 32 MB 2 GB Server GC with &gt; 8 logical CPUs 16 MB 1 GB Segment包括第2代对象，第2代对象会在内存允许的情况尽可能多的申请到内存，并使用多个段进行内存存储。从GC中释放的内存量仅限于Segment的大小，但由于Segment采用动态大小进行了分配，这就使得释放后的大量内存占位导致内存使用率低下，前面也说过了，为了解决这个问题GC要对内存碎片进行整理，并中断所有线程的处理。 .NET Core GC的几种配置模式：Concurrent &amp; Workstation GC12&lt;ServerGarbageCollection&gt;false&lt;/ServerGarbageCollection&gt;&lt;ConcurrentGarbageCollection&gt;true&lt;/ConcurrentGarbageCollection&gt; 特点:在吞吐量和相应速度上寻找平衡点, GC Heap数量为1，GC threads在分配空间的线程,GC线程优先权和工作线程具有相同的优先权，工作线程（非GC线程）会因为GC工作过程中短暂多次挂起。 Background &amp; Workstation GC12&lt;ServerGarbageCollection&gt;false&lt;/ServerGarbageCollection&gt;&lt;ConcurrentGarbageCollection&gt;false&lt;/ConcurrentGarbageCollection&gt; 特点:最大化吞吐量并优化gen2 GC性能, GC Heap数量为1，background GC线程与工作线程有相同优先级，但都低于前台GC线程 ，工作线程（非GC线程）会因为GC工作过程中短暂多次挂起，较并发性能更加（针对Gen2的）。 Concurrent &amp; Server GC12&lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;&lt;ConcurrentGarbageCollection&gt;true&lt;/ConcurrentGarbageCollection&gt; 特点:多处理器机器上使用多线程处理相同类型的请求以便最大化服务程序吞吐量, GC Heap数量为每处理器1个，每个处理器都有一个专职的GC线程,GC线程拥有最高线程的优先级，工作线程（非GC线程）会因为GC工作过程中会被挂起。 Background &amp; Server GC12&lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;&lt;ConcurrentGarbageCollection&gt;false&lt;/ConcurrentGarbageCollection&gt; 特点:在Concurrent &amp; Server GC基础上优化gen2 GC性能, GC Heap数量为每处理器1个，每个处理器都有一个专职的GC background线程,background GC线程与工作线程有相同优先级，但都低于前台GC线程，工作线程（非GC线程）会因为GC工作过程中短暂多次挂起，较并发性能更加（针对Gen2的）ephemeral generation的前台GC工作时会挂起其他所有线程。 GC几种模式的分析 (参考资料):https://blogs.msdn.microsoft.com/seteplia/2017/01/05/understanding-different-gc-modes-with-concurrency-visualizer/ https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals https://github.com/aspnet/Home/issues/2056","tags":[{"name":"dotnet aspnet","slug":"dotnet-aspnet","permalink":"http://maxzhang1985.github.io/tags/dotnet-aspnet/"}]},{"title":"在ASP.NET Core中如何调整HTTP请求大小","date":"2017-09-28T15:37:40.000Z","path":"2017/09/28/aspnetcore-max-request-body-size-limit/","text":"一、前言一般的情况下，我们都无需调用HTTP请求的大小，只有在上传一些大文件，或者使用HTTP协议写入较大的值时（如调用WebService）才可能会调用HTTP最大请求值。 在ASP.NET Core 2.0中，它的两个宿主服务器Kestrel和HttpSys默认的HTTP最大请求大小为30MB (~28.6 MiB)。 如果当HTTP请求值大于这个默认配置时，在执行Request.Body.ReadAsync方法时，就会引发IOException异常。如果这个异常未被捕获，在Kestrel服务器中输出HTTP状态码413(Request Entity Too Large), 而在HttpSys 中的HTTP状态码将是500(Internal Server Error)。 二、解决方案在ASP.NET Core中这个配置可以基于全局和每次请求进行配置。 1.MVC的解决方案MVC Core中为我们提供了两种特性配置请求大小： RequestSizeLimit Attribute，对每个Action的请求大小进行配置。如下调整MyAction的请求大小值为100,000,000 字节.12345[HttpPost][RequestSizeLimit(100_000_000)]public IActionResult MyAction([FromBody] MyViewModel data)&#123;&#125; DisableRequestSizeLimit Attribute可以同时应用到Controller和Action上，以禁用对HTTP请求的大小限制，也是说设置为无限制。12345[HttpPost][DisableRequestSizeLimit]public IActionResult MyAction([FromBody] MyViewModel data)&#123;&#125; 2.请求上下文的解决方案这个方案是一个全局配置方案，会影响到每个请求，当然也可以通过一些灵活的配置对单个请求进行修改，它通过IHttpMaxRequestBodySizeFeature 特征进行配置。如下在HttpContext中取得，当然也可以在ApplicationServices的IOC中获取。1HttpContext.Features.Get&lt;IHttpMaxRequestBodySizeFeature&gt;().MaxRequestBodySize = 100_000_000; IHttpMaxRequestBodySizeFeature特征的MaxRequestBodySize属性是Nullable&lt; long &gt;类型，当设置为null时，类拟于MVC中的[DisableRequestSizeLimit]]。IsReadOnly属性说明此时上下文中的请求大小是否可以修改。 3.全局配置解决方案通过两个宿主服务器Kestrel和HttpSys配置对请求大小进行修改，规则与前两种方案相同。1234.UseKestrel(options =&gt;&#123; options.Limits.MaxRequestBodySize = null;&#125; 1234.UseHttpSys(options =&gt;&#123; options.MaxRequestBodySize = 100_000_000;&#125; 推广GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"aspnet","slug":"aspnet","permalink":"http://maxzhang1985.github.io/tags/aspnet/"}]},{"title":"ASP.NET Core 2.0 SignalR 示例","date":"2017-07-04T11:01:48.000Z","path":"2017/07/04/ASP-NET-Core-2-SignalR/","text":"一、前言上次讲SignalR还是在《在ASP.NET Core下使用SignalR技术》文章中提到，ASP.NET Core 1.x.x 版本发布中并没有包含SignalR技术和开发计划中。时间过得很快，MS已经发布了.NET Core 2.0 Preview 2 预览版，距离正式版已经不远了，上文中也提到过在ASP.NET Core 2.0中的SignalR将做为重要的组件与MVC等框架一起发布。它的开发团队也兑现了承诺，使用TypeScript对它的javascript客户端进行重写，服务端方面也会贴近ASP.NET Core的开发方式，比如会集成到ASP.NET Core依赖注入框架中。 二、环境搭建要在ASP.NET Core 2.0中使用SignalR，要先引用Microsoft.AspNetCore.SignalR 、 Microsoft.AspNetCore.SignalR.Http 两个Package包。 目前ASP.NET Core 2.0与SignalR还都是Preview版本，所以NUGET上也找不到SignalR的程序包，想添加引用我们就得去MyGet上去找找。既然要用MyGet的话，就要为项目添加NuGet源了。 1.添加NuGet源在程序根目录新建一个命为NuGet.Config的文件内容如下： 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;configuration&gt; &lt;packageSources&gt; &lt;clear/&gt; &lt;add key=\"aspnetcidev\" value=\"https://dotnet.myget.org/F/aspnetcore-ci-dev/api/v3/index.json\"/&gt; &lt;add key=\"api.nuget.org\" value=\"https://api.nuget.org/v3/index.json\"/&gt; &lt;/packageSources&gt;&lt;/configuration&gt; 2.编辑项目文件csproj添加上面提到的两个包的引用：123&lt;PackageReference Include=\"Microsoft.AspNetCore.All\" Version=\"2.0.0-preview3-26040\" /&gt;&lt;PackageReference Include=\"Microsoft.AspNetCore.SignalR\" Version=\"1.0.0-preview3-26037\" /&gt;&lt;PackageReference Include=\"Microsoft.AspNetCore.SignalR.Http\" Version=\"1.0.0-preview3-26037\" /&gt; 我在这个示例里使用的是目前的最高,当然版本号每天都有可能发生变化，最新版本的SignalR，是不兼容.NET Core SDK 2.0 Preview 1中默认创建项目时Microsoft.AspNetCore.All这个包的版本的，这里也修改修改一下版本号为：Microsoft.AspNetCore.All 2.0.0-preview3-26040。 3.添加配置代码我们需要在Startup类中的 ConfigureServices方法中添加如下代码：1234public void ConfigureServices(IServiceCollection services)&#123; services.AddSignalR();&#125; 在Startup类中的Configure方法中添加如下代码：12345678public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; app.UseStaticFiles(); app.UseSignalR(routes =&gt; &#123; routes.MapHub&lt;Chat&gt;(\"hubs\"); &#125;);&#125; 4.添加一个HUB类1234567891011121314151617181920212223242526272829303132333435363738394041public class Chat : Hub&#123; public override async Task OnConnectedAsync() &#123; await Clients.All.InvokeAsync(\"Send\", $\"&#123;Context.ConnectionId&#125; joined\"); &#125; public override async Task OnDisconnectedAsync(Exception ex) &#123; await Clients.All.InvokeAsync(\"Send\", $\"&#123;Context.ConnectionId&#125; left\"); &#125; public Task Send(string message) &#123; return Clients.All.InvokeAsync(\"Send\", $\"&#123;Context.ConnectionId&#125;: &#123;message&#125;\"); &#125; public Task SendToGroup(string groupName, string message) &#123; return Clients.Group(groupName).InvokeAsync(\"Send\", $\"&#123;Context.ConnectionId&#125;@&#123;groupName&#125;: &#123;message&#125;\"); &#125; public async Task JoinGroup(string groupName) &#123; await Groups.AddAsync(Context.ConnectionId, groupName); await Clients.Group(groupName).InvokeAsync(\"Send\", $\"&#123;Context.ConnectionId&#125; joined &#123;groupName&#125;\"); &#125; public async Task LeaveGroup(string groupName) &#123; await Groups.RemoveAsync(Context.ConnectionId, groupName); await Clients.Group(groupName).InvokeAsync(\"Send\", $\"&#123;Context.ConnectionId&#125; left &#123;groupName&#125;\"); &#125; public Task Echo(string message) &#123; return Clients.Client(Context.ConnectionId).InvokeAsync(\"Send\", $\"&#123;Context.ConnectionId&#125;: &#123;message&#125;\"); &#125;&#125; 5.客户端支持 在wwwroot目录下创建一个名为chat.html的Html静态文件，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"head1\"&gt;&lt;/h1&gt; &lt;div&gt; &lt;select id=\"formatType\"&gt; &lt;option value=\"json\"&gt;json&lt;/option&gt; &lt;option value=\"line\"&gt;line&lt;/option&gt; &lt;/select&gt; &lt;input type=\"button\" id=\"connect\" value=\"Connect\" /&gt; &lt;input type=\"button\" id=\"disconnect\" value=\"Disconnect\" /&gt; &lt;/div&gt; &lt;h4&gt;To Everybody&lt;/h4&gt; &lt;form class=\"form-inline\"&gt; &lt;div class=\"input-append\"&gt; &lt;input type=\"text\" id=\"message-text\" placeholder=\"Type a message, name or group\" /&gt; &lt;input type=\"button\" id=\"broadcast\" class=\"btn\" value=\"Broadcast\" /&gt; &lt;input type=\"button\" id=\"broadcast-exceptme\" class=\"btn\" value=\"Broadcast (All Except Me)\" /&gt; &lt;input type=\"button\" id=\"join\" class=\"btn\" value=\"Enter Name\" /&gt; &lt;input type=\"button\" id=\"join-group\" class=\"btn\" value=\"Join Group\" /&gt; &lt;input type=\"button\" id=\"leave-group\" class=\"btn\" value=\"Leave Group\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;h4&gt;To Me&lt;/h4&gt; &lt;form class=\"form-inline\"&gt; &lt;div class=\"input-append\"&gt; &lt;input type=\"text\" id=\"me-message-text\" placeholder=\"Type a message\" /&gt; &lt;input type=\"button\" id=\"send\" class=\"btn\" value=\"Send to me\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;h4&gt;Private Message&lt;/h4&gt; &lt;form class=\"form-inline\"&gt; &lt;div class=\"input-prepend input-append\"&gt; &lt;input type=\"text\" name=\"private-message\" id=\"private-message-text\" placeholder=\"Type a message\" /&gt; &lt;input type=\"text\" name=\"user\" id=\"target\" placeholder=\"Type a user or group name\" /&gt; &lt;input type=\"button\" id=\"privatemsg\" class=\"btn\" value=\"Send to user\" /&gt; &lt;input type=\"button\" id=\"groupmsg\" class=\"btn\" value=\"Send to group\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;ul id=\"message-list\"&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=\"signalr-client.js\"&gt;&lt;/script&gt;&lt;script src=\"utils.js\"&gt;&lt;/script&gt;&lt;script&gt;var isConnected = false;function invoke(connection, method, ...args) &#123; if (!isConnected) &#123; return; &#125; var argsArray = Array.prototype.slice.call(arguments); connection.invoke.apply(connection, argsArray.slice(1)) .then(result =&gt; &#123; console.log(\"invocation completed successfully: \" + (result === null ? '(null)' : result)); if (result) &#123; addLine('message-list', result); &#125; &#125;) .catch(err =&gt; &#123; addLine('message-list', err, 'red'); &#125;);&#125; function getText(id) &#123; return document.getElementById(id).value;&#125;let transportType = signalR.TransportType[getParameterByName('transport')] || signalR.TransportType.WebSockets;document.getElementById('head1').innerHTML = signalR.TransportType[transportType];let connectButton = document.getElementById('connect');let disconnectButton = document.getElementById('disconnect');disconnectButton.disabled = true;var connection;click('connect', event =&gt; &#123; connectButton.disabled = true; disconnectButton.disabled = false; let http = new signalR.HttpConnection(`http://$&#123;document.location.host&#125;/hubs`, &#123; transport: transportType &#125;); connection = new signalR.HubConnection(http); connection.on('Send', msg =&gt; &#123; addLine('message-list', msg); &#125;); connection.onClosed = e =&gt; &#123; if (e) &#123; addLine('message-list', 'Connection closed with error: ' + e, 'red'); &#125; else &#123; addLine('message-list', 'Disconnected', 'green'); &#125; &#125; connection.start() .then(() =&gt; &#123; isConnected = true; addLine('message-list', 'Connected successfully', 'green'); &#125;) .catch(err =&gt; &#123; addLine('message-list', err, 'red'); &#125;);&#125;);click('disconnect', event =&gt; &#123; connectButton.disabled = false; disconnectButton.disabled = true; connection.stop() .then(() =&gt; &#123; isConnected = false; &#125;);&#125;);click('broadcast', event =&gt; &#123; let data = getText('message-text'); invoke(connection, 'Send', data);&#125;);click('join-group', event =&gt; &#123; let groupName = getText('message-text'); invoke(connection, 'JoinGroup', groupName);&#125;);click('leave-group', event =&gt; &#123; let groupName = getText('message-text'); invoke(connection, 'LeaveGroup', groupName);&#125;);click('groupmsg', event =&gt; &#123; let groupName = getText('target'); let message = getText('private-message-text'); invoke(connection, 'SendToGroup', groupName, message);&#125;);click('send', event =&gt; &#123; let data = getText('me-message-text'); invoke(connection, 'Echo', data);&#125;);&lt;/script&gt; 值得注意的是，你可能会发现，目前找不到signalr-client.js这个文件，它是怎么来的呢，有两种方式：第1种是通过下载SignalR的源代码，找到Client-TS项目，对TypeScript进行编译可以得到。 第2种比较简单通过Npm可以在线获取：1npm install signalr-client --registry https://dotnet.myget.org/f/aspnetcore-ci-dev/npm/ 三、最后 附上一个可用的Demo：https://github.com/maxzhang1985/AspNetCore.SignalRDemo 。 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"dotnet aspnet","slug":"dotnet-aspnet","permalink":"http://maxzhang1985.github.io/tags/dotnet-aspnet/"}]},{"title":".Net Core中使用ref和Span<T>提高程序性能","date":"2017-05-18T13:53:13.000Z","path":"2017/05/18/netcore2-ref-and-span/","text":"一、前言其实说到ref，很多同学对它已经有所了解，ref是C# 7.0的一个语言特性，它为开发人员提供了返回本地变量引用和值引用的机制。Span也是建立在ref语法基础上的一个复杂的数据类型，在文章的后半部分，我会有一个例子说明如何使用它。 二、ref关键字不论是ref还是out关键，都是一种比较难以理解和操作的语言特性，如C语言中操作指针一样，这样的高级语法总是什么带来一些副作用，但是我不认为这有什么，而且不是每一个C#开发者都要对这些内部运行的机制有着深刻的理解，我觉得不论什么复杂的东西只是为人们提供了一个自由的选择，风险和灵活性永远是不能兼容的。 来看几个例子来说明引用与指针的相同性，当然下面的使用方式早在C# 7.0之前就可以使用了：123456789public static void IncrementByRef(ref int x)&#123; x++;&#125;public unsafe static void IncrementByPointer(int* x)&#123; (*x)++;&#125; 上面两个函数分别是使用ref和非安全指针来完成参数+1。1234567int i = 30;IncrementByRef(ref i);// i = 31unsafe&#123; IncrementByPointer(&amp;i);&#125;// i = 32 下面是C# 7.0提供的特性： 1.ref locals (引用本地变量)1234int i = 42;ref var x = ref i;x = x + 1;// i = 43 这个例子中为本地 i 变量的引用 x, 当改变x的值时i变量的值也改变了。 2.ref returns (返回值引用)ref returns是C# 7中一个强大的特性，下面代码是最能体现其特性的，该函数提供了，返回int数组中某一项的引用：1public static ref int GetArrayRef(int[] items, int index) =&gt; ref items[index]; 通过下标取得数组中的项目的引用，改变引用值时，数组也会随之改变。 三、Span System.Span是.Net Core核心的一部分，在System.Memory.dll 程序集下。目前该特性是独立的，将来可能会集成到CoreFx中； 如何使用呢？在.Net Core 2.0 SDK创建的项目下引用如下NuGet包：1234&lt;ItemGroup&gt; &lt;PackageReference Include=\"System.Memory\" Version=\"4.4.0-preview1-25305-02\" /&gt; &lt;PackageReference Include=\"System.Runtime.CompilerServices.Unsafe\" Version=\"4.4.0-preview1-25305-02\" /&gt;&lt;/ItemGroup&gt; 在上面我们看到了使用ref关键字可以提供的类似指针(T*)的操作单一值对象方式。基本上在.NET体系下操作指针都不认为是一件好的事件，当然.NET为我们提供了安全操作单值引用的ref。但是单值只是用户使用“指针”的一小部分需求；对于指针来说，更常见的情况是操作一系列连续的内存空间中的“元素”时。 Span表示为一个已知长度和类型的连续内存块。许多方面讲它非常类似T[]或ArraySegment，它提供安全的访问内存区域指针的能力。其实我理解它更将是.NET中操作(void*)指针的抽象,熟悉C/C++开发者应该更明白这意味着什么。 Span的特点如下： 抽象了所有连续内存空间的类型系统，包括：数组、非托管指针、堆栈指针、fixed或pinned过的托管数据，以及值内部区域的引用 支持CLR标准对象类型和值类型 支持泛型 支持GC,而不像指针需要自己来管理释放 下面来看下Span的定义，它与ref有着语法和语义上的联系：12345678910111213public struct Span&lt;T&gt; &#123; ref T _reference; int _length; public ref T this[int index] &#123; get &#123;...&#125; &#125; ...&#125;public struct ReadOnlySpan&lt;T&gt; &#123; ref T _reference; int _length; public T this[int index] &#123; get &#123;...&#125; &#125; ...&#125; 接下来我会用一个直观的例子来说明Span的使用场景；我们以字符截取和字符转换（转换为整型）为例： 如有一个字符串string content = “content-length:123”,要转换将123转换为整型，通常的做法是先Substring将与数字字符无关的字符串进行截断，转换代码如下：123456789string content = \"content-length:123\";Stopwatch watch1 = new Stopwatch();watch1.Start();for (int j = 0; j &lt; 100000; j++)&#123; int.Parse(content.Substring(15));&#125;watch1.Stop();Console.WriteLine(\"\\tTime Elapsed:\\t\" + watch1.ElapsedMilliseconds.ToString(\"N0\") + \"ms\"); 为什么使用这个例子呢，这是一个典型的substring的使用场景，每次操作string都会生成新的string对象,当然不光是Substring,在进行int.Parse时重复操作string对象，如果大量操作就会给GC造成压力。 使用Span实现这个算法：12345678910string content = \"content-length:123\";ReadOnlySpan&lt;char&gt; span = content.ToCharArray(); span.Slice(15).ParseToInt();watch.Start();for (int j = 0; j &lt; 100000; j++)&#123; int icb = span.Slice(15).ParseToInt();&#125;watch.Stop();Console.WriteLine(\"\\tTime Elapsed:\\t\" + watch.ElapsedMilliseconds.ToString(\"N0\") + \"ms\"); 这里将string转换为int的算法利用ReadonlySpan实现，这也是Span的典型使用场景，官方给的场景也是如些，Span适用于多次复用操作连续内存的场景。 转换代码如下：123456789101112131415161718public static class ReadonlySpanxtension&#123; public static int ParseToInt(this ReadOnlySpan&lt;char&gt; rspan) &#123; Int16 sign = 1; int num = 0; UInt16 index = 0; if (rspan[0].Equals('-'))&#123; sign = -1; index = 1; &#125; for (int idx = index; idx &lt; rspan.Length; idx++)&#123; char c = rspan[idx]; num = (c - '0') + num * 10; &#125; return num * sign; &#125;&#125; 四、最后上述两段代码100000次调用的时间如下：1234String Substring Convert: Time Elapsed: 18msReadOnlySpan Convert: Time Elapsed: 4ms 目前Span的相关支持还够，它只是最基础架构，之后CoreFx会对很多API使用Span进行重构和实现。可见.Net Core的性能日后会越来越强大。 相关Demo会上传到QQ群中。 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894 。","tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://maxzhang1985.github.io/tags/dotnet/"}]},{"title":"通过修改CoreCLR中的ClrHost实现自托管程序","date":"2017-04-14T10:46:45.000Z","path":"2017/04/14/modifiy-clrhost-and-run/","text":"上一篇我们讲了如何在windows和Linux上编译CoreClr的问题 虽然文章使用的是windows 10 (Bash)环境，但是也可以做为ubuntu环境的参考。 成功编译CoreCLR的源代码之后，会在\\coreclr\\bin\\Product\\Windows_NT.x64.{*}目录生成对应的二进制文件，这里包含了基本的CLR运行时文件。其中就有我们这次想要修改的CoreRun.exe文件，它就是CLRHost的入口可执行程序，等同于dotnet命令。当然本篇文章主要是以windows环境为例，通过修改Windowst版本的CoreRun为例来介绍，如何实现一个自己的自托管程序入口。 要想编辑Windows环境的源代码首先也是同样的需要编译CoreCLR源代码的。成功编译后会在coreclr\\bin\\obj\\Windows_NT.x64.Debug 目录下看到VC++的项目和解决方案。打开CoreCLR.sln解决方案，可以看到其中的CoreRun项目。 首先它是一个Win32项目，我在这里只简单的讲几处关键的代码段，有兴趣的同学可以到Github上去看看CoreRun源代码 。 先说一下我们想要达到的效果吧：想要使用CoreRun启动一个dotnet程序集只需要如下命令：1corerun demo.dll 当然想真正执行起来，还需要在系统环境变量里添加CORE_ROOT来指定已经安装的CoreCLR目录。 但这次想达到的目标是不需要指定Runtime目录也不需要指定dll文件名，如下：1demo.exe 这样是不是写发布一个自托管程序是一样的？接下来，我们来通过修改代码来实现这一目标。 首先找到HostEnvironment类，看下它的代码段第112行：1234567StackSString coreRoot;m_coreCLRModule = NULL; // Initialize this here since we don't call TryLoadCoreCLR if CORE_ROOT is unset.if (WszGetEnvironmentVariable(W(\"CORE_ROOT\"), coreRoot) &gt; 0 &amp;&amp; coreRoot.GetCount() &gt; 0)&#123; coreRoot.Append(W('\\\\')); m_coreCLRModule = TryLoadCoreCLR(coreRoot);&#125; 它通过获取系统环境变量CORE_ROOT的值来定位CoreCLR目录，并传递给TryLoadCoreCLR函数，来加载CoreCLR.dll文件。 下面来到主函数TryRun:12345678910111213141516171819202122232425262728293031323334//获取命令行参数数组的指针const wchar_t* exeName = argc &gt; 0 ? argv[0] : nullptr;if(exeName == nullptr)&#123; log &lt;&lt; W(\"No exename specified.\") &lt;&lt; Logger::endl; return false;&#125;StackSString appPath;StackSString appNiPath;StackSString managedAssemblyFullName;StackSString appLocalWinmetadata;wchar_t* filePart = NULL;COUNT_T size = MAX_LONGPATH;//获取可执行文件路径，如:src\\coreclr\\hosts\\corerun\\Debug\\CoreRun.exewchar_t* appPathPtr = appPath.OpenUnicodeBuffer(size - 1);DWORD length = WszGetFullPathName(exeName, size, appPathPtr, &amp;filePart);if (length &gt;= size)&#123; appPath.CloseBuffer(); size = length; //获取程序集名称，如:Demo.dll appPathPtr = appPath.OpenUnicodeBuffer(size - 1); length = WszGetFullPathName(exeName, size, appPathPtr, &amp;filePart);&#125;if (length == 0 || length &gt;= size) &#123; log &lt;&lt; W(\"Failed to get full path: \") &lt;&lt; exeName &lt;&lt; Logger::endl; log &lt;&lt; W(\"Error code: \") &lt;&lt; GetLastError() &lt;&lt; Logger::endl; return false;&#125; //设置程序集名称变量managedAssemblyFullName.Set(appPathPtr); 中间的代码就省略了，无非是创建ICLRRuntimeHost2接口，加载参数如gc_server等之后就是创建AppDomain生成domainId。123456//这里启动的就是上面设置的程序集的全路径hr = host-&gt;ExecuteAssembly(domainId, managedAssemblyFullName, argc-1, (argc-1)?&amp;(argv[1]):NULL, &amp;exitCode);if (FAILED(hr)) &#123; log &lt;&lt; W(\"Failed call to ExecuteAssembly. ERRORCODE: \") &lt;&lt; Logger::hresult &lt;&lt; hr &lt;&lt; Logger::endl; return false;&#125; ExecuteAssembly函数会真正的通过domainId执行这个程序集。 其实讲到这里有的朋友应该已经明白了，想要达到我们的目标，只需要做两件事儿。 1.修改CORE_ROOT的加载方式首先修改HostEnvironment类，将获取环境CORE_ROOT的代码去掉，然后修改构造函数将路径作为参数（coreRoot）传入。 12345HostEnvironment(StackSString coreRoot, Logger *logger) : m_log(logger), m_CLRRuntimeHost(nullptr) &#123; //......省略代码 // m_coreCLRModule = TryLoadCoreCLR(coreRoot); 这里我使用的方式为不加载环境变量，而是指向加载目录（也就是程序执行目录appPath或是指向子目录），我使用的是后者指向了一个名为Runtimes的子目录。 2.修改程序集路径的获取方式123456789101112131415161718192021222324//声明程序集路径变量StackSString assemblyPath;//获取可执行文件路径assemblyPath.Set(appPathPtr);SString::CIterator lastBackslash = assemblyPath.End();assemblyPath.FindBack(lastBackslash, W('\\\\'));//分离路径与文件名,如 ../corerun/bin/debug/ 和 corerun.exemanagedAssemblyFullName.Set(assemblyPath, assemblyPath.Begin(), lastBackslash + 1);//声明临时变量计算程序集文件名StackSString tempName;StackSString assemblyName;tempName.Set(filePart);auto endofName = tempName.End();//查找到扩展名标志\".\"位置tempName.FindBack(endofName, W('.'));assemblyName.Set(tempName, tempName.Begin(), endofName + 1);//替换exe为dllassemblyName.Append(W(\"dll\"));managedAssemblyFullName.Append(assemblyName);*(filePart) = W('\\0');appPath.CloseBuffer(DWORD(filePart - appPathPtr));//打印完整的dll路径log &lt;&lt; W(\"Loading: \") &lt;&lt; managedAssemblyFullName.GetUnicode() &lt;&lt; Logger::endl; 想实现自托管的方式，就可以参考dotnet publish的生成文件，它生成是将可执行文件.exe与程序集文件同名如: demo.exe 、 demo.dll 这样的文件组织方式。其实解决方案就是得到exeName后，获取当前执行文件的全路径，提取出路径和文件名两个部分，并将文件名进行替换，这样可执行文件在加载时就会默认加载与它同名的程序集文件，来做为ExecuteAssembly的参数来执行些程序集。 Demo和修改的源代码，已经上传到QQ群文件中（Demos\\CoreCLRDemo.zip），仅供参考。 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"dotnet coreclr","slug":"dotnet-coreclr","permalink":"http://maxzhang1985.github.io/tags/dotnet-coreclr/"}]},{"title":"如何在多个项目中分离Asp.Net Core Mvc的Controller和Areas","date":"2017-04-07T17:21:28.000Z","path":"2017/04/07/muti-projects-mvc-areas/","text":"前言软件系统中总是希望做到松耦合，项目的组织形式也是一样，本篇文章将介绍在ASP.NET CORE MVC中怎么样将Controller与主网站项目进行分离，并且对Areas进行支持。 实践1.新建项目新建两个ASP.NET Core Web应用程序，一个命名为:WebHostDemo 另一个名为: Web.Controllers ，看名字可以知道第一个项目是主程序项目，第二个是存放Controller类和Areas的项目。 2.修改Mvc配置在WebHostDemo项目中修改ConfigureServices函数：12345678910111213141516171819public void ConfigureServices(IServiceCollection services)&#123; // Add framework services. services.AddMvc(); var manager = new ApplicationPartManager(); var homeType = typeof(Web.Controllers.Areas.HomeController); var controllerAssembly = homeType.GetTypeInfo().Assembly; manager.ApplicationParts.Add(new AssemblyPart(controllerAssembly)); manager.FeatureProviders.Add(new ControllerFeatureProvider()); var feature = new ControllerFeature(); manager.PopulateFeature(feature); services.AddSingleton(feature.Controllers.Select(t =&gt; t.AsType()).ToArray());&#125; 这样就将另一个项目中的Controller程序集注入到主程序中了。当然还可以通过另一种方式：123456789public void ConfigureServices(IServiceCollection services)&#123; services.AddMvc().ConfigureApplicationPartManager( m =&gt; &#123; var feature = new ControllerFeature(); m.ApplicationParts.Add(new AssemblyPart(controllerAssembly)); m.PopulateFeature(feature); services.AddSingleton(feature.Controllers.Select(t =&gt; t.AsType()).ToArray()); &#125;);&#125; 这两种方式都可以注入Controller。 接下来修改Configure函数以，通过修改路由让Mvc支持Areas：1234567891011app.UseMvc(routes =&gt;&#123; routes.MapRoute( name: \"areaRoute\", template: \"&#123;area:exists&#125;/&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;\"); routes.MapRoute( name: \"default\", template: \"&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;\");&#125;); 3.添加Areas在Web.Controllers项目中建立如下目录结构：Areas123456MyArea1 -Controllers -Home.cs -Views -Home Index.cshtml 4.为Controller添加Area12345678 [Area(\"MyArea1\")]public class HomeController : Controller&#123; public IActionResult Index() &#123; return View(); &#125;&#125; 最后还有一件事很重要，当我们这么将项目进行分离后，DEBUG主程序将没办法找到Areas和Views目录，所以DEBUG时，要将这些目录Copy到主程序代码根目录，当然如果是发布程序的话就没有这个问题。 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894 Demo已经上传到群文件中，仅供参考。","tags":[{"name":"dotnet aspnet","slug":"dotnet-aspnet","permalink":"http://maxzhang1985.github.io/tags/dotnet-aspnet/"}]},{"title":"Win10 Bash/WSL调试Linux环境下的.NET Core应用程序","date":"2017-03-29T14:47:08.000Z","path":"2017/03/29/debug-dotnetcore-with-bash/","text":"一、简介使用过Mac OS的程序员都知道,在Mac Book Pro上写程序是一件比较爽的事儿,作为dotneter，我们都比较羡慕Mac系统的环境,比如命令行,当然设备也是挺漂亮的。 在新的Win10系统中微软给我们提供了一个基于Ubuntu的Linux子系统（Bash/WSL）。要全用Bash/WSL也比较简单，首先要先打开开发者模式（ 设置 → 更新和安全 → 针对开发人员 → 开发人员模式）, 然后在控制面板 → 程序 → 启用Windows功能 → Windows Subsystem for Linux (Beta)对Bash功能进行安装即可。 二、配置环境本文中使用的环境： 开发环境：Win10 、Visual Studio 2017、.NET Core SDK 1.0.1 (Win与Linux子系统保持版本一致) Bash/WSL中安装.NET Core SDK1.更新Ubuntu子系统的软件源12345sudo sh -c 'echo \"deb [arch=amd64] https://apt-mo.trafficmanager.net/repos/dotnet-release/ trusty main\" &gt; /etc/apt/sources.list.d/dotnetdev.list'sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 417A0893sudo apt-get update 2.安装.NET Core SDK1sudo apt-get install dotnet-dev-1.0.1 3.安装SSH子系统间的通信，因为系统不同还是需要安装SSH服务器，unzip和 curl或wget这些组件的。1sudo apt-get install openssh-server unzip curl 安装SSH后,系统并不能访问本机的系统的端口做通信,还需要配置一个SSH服务器的配置文件。 运行如下命令：1sudo nano /etc/ssh/sshd_config 分别找到如下配置项做修改，修改后的内容如下：12345UsePAM noUsePrivilegeSeparation noPasswordAuthentication yes 修改后，按CTRL+X键退出并按Y键保存文件，回车回车。最后重启下SSH服务。1sudo service ssh --full-restart 三、调试程序启动SSH 每次 新建程序 打开VS 2017 新建一个控制台应用.NET Core,并进行编译。 附加调试 接着默认运行起程序，然后在VS 2017 打开 调试-&gt; 附加到进程 。选择连接类型为SSH ，然后连接和目标处 输入 localhost，然后回车，会弹出对话，输入对应的用户名密码(这里的密码是安装Bash/WSL后设置的用户名和密码)。 好了，这样就可以只在Windows上安心的写程序了。 .NET Core 开源学习群：214741894 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。","tags":[]},{"title":"Win10上编译CoreCLR的Windows和Linux版本","date":"2017-03-21T16:30:12.000Z","path":"2017/03/21/vs2017-build-coreclr-1/","text":"一、编译环境首先，不管是Windows还是Linux版本CoreCLR的编译，都是在Windows10上进行的。 二、CoreCLR for Windows在Windows上做编译怎么能少得了Visual Studio,由于Visual Studio 2017刚刚发布，所以选用Visual Studio 2017版本作为编译工具。 编译组件Visual Studio 2017安装组件.NET Desktop Development All Required Components .NET Framework 4-4.6 Development Tools Desktop Development with C++ All Required Components VC++ 2017 v141 Toolset (x86, x64) Windows 8.1 SDK and UCRT SDK VC++ 2015.3 v140 Toolset (x86, x64) 还有一个比较重要的问题，就是使用VS2017的话，还需要注册一个Visual Studio 2015的组件，需要运行如下命令：regsvr32.exe %VSINSTALLDIR%\\Common7\\IDE\\msdia120.dll ，因为需要VS2017的环境变量，当然这也需要在Developer Command Prompt for VS2017 中运行。还有最重要一点Visual Studio Express 2017不支持编译CoreCLR。 CMake要编译CoreCLR需要CMake 3.7.2及以上版本，记得加环境变量Path。 Python官方给出的所需版本为 python 2.7.9，但是python 3也能很好的支持，记得加环境变量Path。 Git这个是必需的嘛。 PowerShellWindows 10 自带4.0，所以Win10就没问题。 DotNet Core SDK不需要解释吧，没有去官网下载吧。 windows编译其实这部分有个小插曲就是，如果使用Visual Studio 2017编译的话会有一个小BUG，文档上给的例子是直接运行命令:1./build.cmd 但是会得到如下结果：1Microsoft.CSharp.Core.targets(106,11): error MSB4064: The &quot;OverrideToolHost&quot; parameter is not supported by the &quot;Csc&quot; task. Verify the parameter exists on the task, and it is a settable public instance property. BUG的地址如下：https://github.com/dotnet/coreclr/issues/10056 运行下面三条命令其中之一就可以解决这个问题了，解决方法如下：12345build x64 skiptests -- /p:CSharpCoreTargetsPath=Roslyn\\Microsoft.CSharp.Core.targetsbuild x64 checked skiptests -- /p:CSharpCoreTargetsPath=Roslyn\\Microsoft.CSharp.Core.targetsbuild x64 release skiptests -- /p:CSharpCoreTargetsPath=Roslyn\\Microsoft.CSharp.Core.targets 推荐第一条命令，生成DEBUG版本。 三、CoreCLR for Linux这里使用Windows 10编译Linux版本是因为Win10里带有Bash，bash是一个基于Ubuntu 14.04的Windows子系统，可以“完美”模拟Linux环境，当然下面所讲的过程也完全可以在真正的Ubuntu上编译。 系统官方推荐的是ubuntu 14.04，当然也可以是别的Linux版本，本文也是使用这个版本进行的。 系统组件 cmake llvm-3.5 clang-3.5 lldb-3.6 lldb-3.6-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libcurl4-openssl-dev libssl-dev uuid-dev git 要安装lldb-3.6需要在Ubuntu上添加安装源：12345echo \"deb http://llvm.org/apt/trusty/ llvm-toolchain-trusty-3.6 main\" | sudo tee /etc/apt/sources.list.d/llvm.listwget -O - http://llvm.org/apt/llvm-snapshot.gpg.key | sudo apt-key add -sudo apt-get update 如果系统里没有git的话，需要自己安装下。接着要安装组件，命令如下：1sudo apt-get install cmake llvm-3.5 clang-3.5 lldb-3.6 lldb-3.6-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libcurl4-openssl-dev libssl-dev uuid-dev Linux编译1./build.sh 四、总结Linux上的编译相对比较简单，但是如果是DEBUG的话，Windows版本要很容易实现。编译两个版本的过程中会经过漫长的等待（最好找个代理）。 下篇文章我会讲下在Windows环境下的调试，还有我做的一些小的修改过程。","tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://maxzhang1985.github.io/tags/dotnet/"}]},{"title":".Net Core迁移到MSBuild平台（二）","date":"2017-03-14T22:26:43.000Z","path":"2017/03/14/project-json-to-csproj/","text":"一、前言在上一篇文章.Net Core迁移到MSBuild的多平台编译问题中，简单的讲了下新的项目配置文件中的节点配置，这篇我将用一些例子来详细讲下从project.json迁移到msbuild过程的节点配置。做过完整迁移新项目配置文件的朋友，肯定会觉得新的项目配置文件Msbuild的配置太扯了，虽然能直接编辑项目文件，但整个配置文件中没有了像project.json中的智能提示，当你在打开文件后你就会发现以前很轻松能写出来的json配置，现在已经什么都写不出来了，而且也没有文档可以参考，一般的情况下，往往开发人员就会关掉项目文件，打开NuGet管理器来进行包引用，但是这真的够用吗？不是所有的配置都能用可视化的方法来完成。 二、XML定义新的.csproj是基于xml格式的，下面介绍下project.json与.csproj文件的差异定义的例子： 项目名称 (ProjectName)123&#123; \"name\": \"MyProjectName\"&#125; 在csproj的配置中并没有对应的定义，它只会有项目文件名相同如：MyProjectName.csproj 程序集版本 (Version)123&#123; \"version\": \"1.0.0-alpha-*\"&#125; 1234&lt;PropertyGroup&gt; &lt;VersionPrefix&gt;1.0.0&lt;/VersionPrefix&gt; &lt;VersionSuffix&gt;alpha&lt;/VersionSuffix&gt;&lt;/PropertyGroup&gt; 当然也可以只使用Version来定义：123&lt;PropertyGroup&gt; &lt;Version&gt;1.0.0-alpha&lt;/Version&gt;&lt;/PropertyGroup&gt; 程序集描述123456789&#123; \"authors\": [ \"Anne\", \"Bob\" ], \"company\": \"Contoso\", \"language\": \"en-US\", \"title\": \"My library\", \"description\": \"This is my library.\\r\\nAnd it's really great!\", \"copyright\": \"Nugetizer 3000\", \"userSecretsId\": \"xyz123\"&#125; 12345678910&lt;PropertyGroup&gt; &lt;Authors&gt;Anne;Bob&lt;Authors&gt; &lt;Company&gt;Contoso&lt;Company&gt; &lt;NeutralLanguage&gt;en-US&lt;/NeutralLanguage&gt; &lt;AssemblyTitle&gt;My library&lt;/AssemblyTitle&gt; &lt;Description&gt;This is my library.And it's really great!&lt;/Description&gt; &lt;Copyright&gt;Nugetizer 3000&lt;/Copyright&gt; &lt;UserSecretsId&gt;xyz123&lt;/UserSecretsId&gt;&lt;/PropertyGroup&gt; frameworks (单目标框架)123\"frameworks\": &#123; \"netcoreapp1.0\": &#123;&#125;&#125; 123&lt;PropertyGroup&gt; &lt;TargetFramework&gt;netcoreapp1.0&lt;/TargetFramework&gt;&lt;/PropertyGroup&gt; frameworks (多目标框架)1234\"frameworks\": &#123; \"netcoreapp1.0\": &#123;&#125;, \"net451\": &#123;&#125; &#125; 123&lt;PropertyGroup&gt; &lt;TargetFrameworks&gt;netcoreapp1.0;net451&lt;/TargetFrameworks&gt;&lt;/PropertyGroup&gt; dependencies (框架依赖)123\"dependencies\": &#123; \"Microsoft.AspNetCore\": \"1.1.0\" &#125; 123&lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.AspNetCore\" Version=\"1.1.0\" /&gt;&lt;/ItemGroup&gt; 不同目标框架的依赖 (Per-framework dependencies)1234567891011121314&#123; &quot;framework&quot;: &#123; &quot;net451&quot;: &#123; &quot;dependencies&quot;: &#123; &quot;System.Collections.Immutable&quot;: &quot;1.3.1&quot; &#125; &#125;, &quot;netstandard1.5&quot;: &#123; &quot;dependencies&quot;: &#123; &quot;Newtonsoft.Json&quot;: &quot;9.0.1&quot; &#125; &#125; &#125;&#125; 1234567&lt;ItemGroup Condition=\"'$(TargetFramework)'=='net451'\"&gt; &lt;PackageReference Include=\"System.Collections.Immutable\" Version=\"1.3.1\" /&gt;&lt;/ItemGroup&gt;&lt;ItemGroup Condition=\"'$(TargetFramework)'=='netstandard1.5'\"&gt; &lt;PackageReference Include=\"Newtonsoft.Json\" Version=\"9.0.1\" /&gt;&lt;/ItemGroup&gt; imports (兼容导入)12345678910111213 &#123; \"dependencies\": &#123; \"xxx\": \"1.0-pre001\" &#125;, \"frameworks\": &#123; \"netcoreapp1.0\": &#123; \"imports\": [ \"dnxcore50\", \"dotnet\" ] &#125; &#125;&#125; 123456&lt;PropertyGroup&gt; &lt;PackageTargetFallback&gt;dnxcore50;dotnet&lt;/PackageTargetFallback&gt;&lt;/PropertyGroup&gt;&lt;ItemGroup&gt; &lt;PackageReference Include=\"xxx\" Version=\"1.0-pre001\" /&gt;&lt;/ItemGroup&gt; 依赖类型 (dependency type)type: build12345678&#123; \"dependencies\": &#123; \"Microsoft.EntityFrameworkCore.Design\": &#123; \"version\": \"1.1.0\", \"type\": \"build\" &#125; &#125;&#125; 123&lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Design\" Version=\"1.1.0\" PrivateAssets=\"All\" /&gt;&lt;/ItemGroup&gt; type: platform12345678&#123; \"dependencies\": &#123; \"Microsoft.NETCore.App\": &#123; \"version\": \"1.1.0\", \"type\": \"platform\" &#125; &#125;&#125; 在*.csproj项目配置文件中没有对应的配置节点,只有目标框架定义：1&lt;TargetFramework&gt;netcoreapp1.1&lt;/TargetFramework&gt; 之前想要编译出独立发布的可执行文件，就需要把 “type”: “platform”节点删除掉。 独立发布定义 (runtimes)1234567&#123; \"runtimes\": &#123; \"win7-x64\": &#123;&#125;, \"osx.10.11-x64\": &#123;&#125;, \"ubuntu.16.04-x64\": &#123;&#125; &#125;&#125; 123&lt;PropertyGroup&gt; &lt;RuntimeIdentifiers&gt;win7-x64;osx.10-11-x64;ubuntu.16.04-x64&lt;/RuntimeIdentifiers&gt;&lt;/PropertyGroup&gt; 现在想生成独立发布版本，只需要在项目配置中定义RuntimeIdentifiers节点，并运行如下命令：1dotnet publish --framework netcoreapp1.0 --runtime osx.10.11-x64 DOTNET CLI工具 (tools)12345&#123; \"tools\": &#123; \"Microsoft.EntityFrameworkCore.Tools.DotNet\": \"1.0.0-*\" &#125;&#125; 123&lt;ItemGroup&gt; &lt;DotNetCliToolReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"1.0.0\" /&gt;&lt;/ItemGroup&gt; 提示：tools下的引用，不再支持“imports”节点定义(不能兼容非dotnet core版本的tools)。 编译可执行 (emitEntryPoint)12345&#123; \"buildOptions\": &#123; \"emitEntryPoint\": true &#125;&#125; 123&lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt;&lt;/PropertyGroup&gt; 12345&#123; \"buildOptions\": &#123; \"emitEntryPoint\": false &#125;&#125; 123&lt;PropertyGroup&gt; &lt;OutputType&gt;Library&lt;/OutputType&gt;&lt;/PropertyGroup&gt; 程序集强命名签名 (keyFile)12345&#123; \"buildOptions\": &#123; \"keyFile\": \"MyKey.snk\" &#125;&#125; 12345&lt;PropertyGroup&gt; &lt;AssemblyOriginatorKeyFile&gt;MyKey.snk&lt;/AssemblyOriginatorKeyFile&gt; &lt;SignAssembly&gt;true&lt;/SignAssembly&gt; &lt;PublicSign Condition=\"'$(OS)' != 'Windows_NT'\"&gt;true&lt;/PublicSign&gt;&lt;/PropertyGroup&gt; 其它编译设置123456789101112&#123; \"buildOptions\": &#123; \"warningsAsErrors\": true, \"nowarn\": [\"CS0168\", \"CS0219\"], \"xmlDoc\": true, \"preserveCompilationContext\": true, \"outputName\": \"Different.AssemblyName\", \"debugType\": \"portable\", \"allowUnsafe\": true, \"define\": [\"TEST\", \"OTHERCONDITION\"] &#125;&#125; 12345678910&lt;PropertyGroup&gt; &lt;TreatWarningsAsErrors&gt;true&lt;/TreatWarningsAsErrors&gt; &lt;NoWarn&gt;$(NoWarn);CS0168;CS0219&lt;/NoWarn&gt; &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt; &lt;PreserveCompliationContext&gt;true&lt;/PreserveCompliationContext&gt; &lt;AssemblyName&gt;Different.AssemblyName&lt;/AssemblyName&gt; &lt;DebugType&gt;portable&lt;/DebugType&gt; &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt; &lt;DefineConstants&gt;$(DefineConstants);TEST;OTHERCONDITION&lt;/DefineConstants&gt;&lt;/PropertyGroup&gt; 打包设置 (packOptions)12345678910111213141516&#123; \"packOptions\": &#123; \"summary\": \"A bundle of cats\", \"tags\": [\"hyperscale\", \"cats\"], \"owners\": [ \"Nate\", \"Jenna\" ], \"releaseNotes\": \"Version 1.0\", \"iconUrl\": \"https://icons.com/awesomeness.png\", \"projectUrl\": \"https://github.com/natemcmaster\", \"licenseUrl\": \"https://www.apache.org/licenses/LICENSE-2.0\", \"requireLicenseAcceptance\": false, \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/natemcmaster/natemcmaster.github.io\" &#125; &#125;&#125; 123456789101112&lt;PropertyGroup&gt; &lt;Description&gt;A bundle of cats&lt;/Description&gt; &lt;PackageTags&gt;hyperscale;cats&lt;/PackageTags&gt; &lt;PackageReleaseNotes&gt;Version 1.0&lt;/PackageReleaseNotes&gt; &lt;PackageIconUrl&gt;https://icons.com/awesomeness.png&lt;/PackageIconUrl&gt; &lt;PackageProjectUrl&gt;https://github.com/natemcmaster&lt;/PackageProjectUrl&gt; &lt;PackageLicenseUrl&gt;https://www.apache.org/licenses/LICENSE-2.0&lt;/PackageLicenseUrl&gt; &lt;PackageRequireLicenseAcceptance&gt;false&lt;/PackageRequireLicenseAcceptance&gt; &lt;RepositoryType&gt;git&lt;/RepositoryType&gt; &lt;RepositoryUrl&gt;https://github.com/natemcmaster/natemcmaster.github.io&lt;/RepositoryUrl&gt; &lt;!-- regrettably, 'owners' does not translate to MSBuild. --&gt;&lt;/PropertyGroup&gt; MsBuild脚本123456&#123; \"scripts\": &#123; \"precompile\": \"generateCode.cmd\", \"postpublish\": [ \"obfuscate.cmd\", \"removeTempFiles.cmd\" ] &#125;&#125; 1234567&lt;Target Name=\"MyPreCompileTarget\" BeforeTargets=\"Build\"&gt; &lt;Exec Command=\"generateCode.cmd\" /&gt;&lt;/Target&gt;&lt;Target Name=\"MyPostCompileTarget\" AfterTargets=\"Publish\"&gt; &lt;Exec Command=\"obfuscate.cmd\" /&gt; &lt;Exec Command=\"removeTempFiles.cmd\" /&gt;&lt;/Target&gt; 运行时设置 (runtimeOptions)1234567891011&#123; \"runtimeOptions\": &#123; \"configProperties\": &#123; \"System.GC.Server\": true, \"System.GC.Concurrent\": true, \"System.GC.RetainVM\": true, \"System.Threading.ThreadPool.MinThreads\": 10, \"System.Threading.ThreadPool.MaxThreads\": 100 &#125; &#125;&#125; 12345678&lt;PropertyGroup&gt; &lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt; &lt;ConcurrentGarbageCollection&gt;true&lt;/ConcurrentGarbageCollection&gt; &lt;RetainVMGarbageCollection&gt;true&lt;/RetainVMGarbageCollection&gt; &lt;!-- I'm not suggesting these settings...just showing usage ;) --&gt; &lt;ThreadPoolMinThreads&gt;10&lt;/ThreadPoolMinThreads&gt; &lt;ThreadPoolMaxThreads&gt;100&lt;/ThreadPoolMaxThreads&gt;&lt;/ProeprtyGroup&gt; 当然如果你创建的是一个web项目的话，及Microsoft.NET.Sdk.Web。那么 ServerGarbageCollection设置将默认为true。 项目文件管理123456789101112131415161718192021222324&#123; \"buildOptions\": &#123; \"compile\": &#123; \"copyToOutput\": \"notes.txt\", \"include\": \"../Shared/*.cs\", \"exclude\": \"../Shared/Not/*.cs\" &#125;, \"embed\": &#123; \"include\": \"../Shared/*.resx\" &#125; &#125;, \"packOptions\": &#123; \"include\": \"Views/\", \"mappings\": &#123; \"some/path/in/project.txt\": \"in/package.txt\" &#125; &#125;, \"publishOptions\": &#123; \"include\": [ \"files/\", \"publishnotes.txt\" ] &#125;&#125; 1234567891011121314151617181920212223&lt;ItemGroup&gt; &lt;Compile Include=\"..\\Shared\\*.cs\" Exclude=\"..\\Shared\\Not\\*.cs\" /&gt; &lt;EmbeddedResource Include=\"..\\Shared\\*.resx\" /&gt; &lt;Content Include=\"Views\\**\\*\" PackagePath=\"%(Identity)\" /&gt; &lt;None Include=\"some/path/in/project.txt\" Pack=\"true\" PackagePath=\"in/package.txt\" /&gt; &lt;None Include=\"notes.txt\" CopyToOutputDirectory=\"Always\" /&gt; &lt;!-- CopyToOutputDirectory = &#123; Always, PreserveNewest, Never &#125; --&gt; &lt;Content Include=\"files\\**\\*\" CopyToPublishDirectory=\"PreserveNewest\" /&gt; &lt;None Include=\"publishnotes.txt\" CopyToPublishDirectory=\"Always\" /&gt; &lt;!-- CopyToPublishDirectory = &#123; Always, PreserveNewest, Never &#125; --&gt; &lt;!-- you can set both copy output and publish directories--&gt; &lt;None Include=\"testasset.txt\" CopyToOutputDirectory=\"Always\" CopyToPublishDirectory=\"Always\" /&gt; &lt;!-- alternatively, use nested XML attributes. They're functionally the same--&gt; &lt;None Include=\"testasset2.txt\"&gt; &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt; &lt;CopyToPublishDirectory&gt;Always&lt;/CopyToPublishDirectory&gt; &lt;/None&gt;&lt;/ItemGroup&gt; 单元测试xunit123456&#123; \"testRunner\": \"xunit\", \"dependencies\": &#123; \"dotnet-test-xunit\": \"&lt;any&gt;\" &#125;&#125; 12345&lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"15.0.0\" /&gt; &lt;PackageReference Include=\"xunit\" Version=\"2.2.0\" /&gt; &lt;PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.2.0\" /&gt;&lt;/ItemGroup&gt; mstest123456&#123; \"testRunner\": \"mstest\", \"dependencies\": &#123; \"dotnet-test-mstest\": \"&lt;any&gt;\" &#125;&#125; 12345&lt;ItemGroup&gt; &lt;PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"15.0.0\" /&gt; &lt;PackageReference Include=\"MSTest.TestAdapter\" Version=\"1.1.12\" /&gt; &lt;PackageReference Include=\"MSTest.TestFramework\" Version=\"1.1.11\" /&gt;&lt;/ItemGroup&gt; 三、结语说实话MSBuild的项目配置系统还是比较灵活的，以后整个dotnet体系的构建过程也都得到了统一。在dotnet cli中也集成了msbuild,即dotnet build。 .NET Core 开源学习群：214741894 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。","tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://maxzhang1985.github.io/tags/dotnet/"}]},{"title":".Net Core迁移到MSBuild的多平台编译问题","date":"2017-02-28T22:26:43.000Z","path":"2017/02/28/Core迁移到MSBuild的多平台编译问题/","text":"一、前言本篇主要讨论.NET Core应用程序项目结构的主题，重点探索.NET Core应用程序的多平台编译问题，这里指的多平台是指.NET Framework、.NET Core App、.NET Standard、Mono、UWP等多平台的条件编译、项目（包）引用、编译符号等问题。 .NET Core已经将新的项目管理配置过渡回MSBuild编译系统中。虽然现在可以从无到有的使用VS2017来创建一个新的MSBuild项目，但是还是有好多遗留程序使用着以JSON格式存储的项目配置文件为基础的项目。Scott Hanselman也在博客中发文教大家怎么使用新的.NET SDK RC4工具将project.json转换到MSBuild的.csproj项目系统。当然这篇文章也解释了MS为什么要这么做。 MSBuild 是一种基于 XML 的项目文件格式的项目配置文件。这种格式容易理解、易于扩展并且完全受 Microsoft 支持。MSBuild 项目文件的格式使开发人员能够充分描述哪些项需要生成，以及如何利用不同的平台和配置生成这些项。另外，项目文件的格式还使开发人员能够创作可重用的生成规则，这些规则可以分解到不同的文件中，以便可以在产品内的不同项目之间一致地执行生成。 当时ASP.NET Core的第一个版本为了使开源平台对开发者更具吸引力，ASP.NET Core采用了一种基于JSON的项目系统project.json文件定义，这是一种与Node.js类似的定义，这对于吸引Web开发者来说是个明智的选择。 但是随着.NET Core的整体开源，非Web开发者如UWP和Xamarin，对这种JSON项目结构并不熟悉。这些开发者和社区都希望继续使用MSBuild的XML项目系统。因些微软宣布他们将为.NET Core重新启用和规范MSBuild构建系统。 在最新的.NET Core SDK 1.0 RC4 版本中，dotnet cli(命令行接口,dotnet cli 1.0.0-preview3-004056及以后版本)已经包含了”dotnet migrate”命令,这个命令为了将JSON为基础的配置项目转换为.csproj项目配置文件。 本文不再谈论如何使用新dotnet cli命令行，而卓重讨论多平台编译问题。 二、定义多平台project.json在project.json项目配置中定义多平台，使用的是”frameworks”节点来配置的，并且在每个平台节点下也配置了对应的项目引用或依赖。下面的实例使用project.json定义的多平台和依赖如下：12345678910111213\"frameworks\": &#123; \"net451\": &#123; \"frameworkAssemblies\": &#123; \"System.Xml\": \"4.0.0.0\", &#125; &#125;, \"netstandard1.6\": &#123; \"dependencies\": &#123; \"System.Runtime\":\"4.1.0\", \"System.Xml.XmlSerializer\": \"4.0.11\" &#125;, &#125;&#125; MSBuild在.csproj项目配置中定义多平台，要使用”TargetFrameworks”的XML节点来配置：1&lt;TargetFrameworks&gt;netstandard1.6;net45;&lt;/TargetFrameworks&gt; 如果要定义某个平台下的依赖引用的话需要如下定义：123456&lt;ItemGroup Condition=\" '$(TargetFramework)' == 'net45' \"&gt; &lt;Reference Include=\"System.Xml\" /&gt;&lt;/ItemGroup&gt;&lt;ItemGroup Condition=\" '$(TargetFramework)' == 'netstandard1.6' \"&gt; &lt;PackageReference Include=\"System.Xml.XmlSerializer\" Version=\"4.0.11\"/&gt;&lt;/ItemGroup&gt; 当然有时候我们还需要对某个平台定义，定义编译符号常量：123&lt;PropertyGroup Condition=\"'$(TargetFramework)' == 'netstandard1.6'\"&gt; &lt;DefineConstants&gt;$(DefineConstants);NETSTANDARD&lt;/DefineConstants&gt;&lt;/PropertyGroup&gt; 这些代码中就可以针对平台特性来编写代码了：123#if NETSTANDARD //netstandard1.*平台代码#endif 如果我们想在某个平台下，只编译某些文件，也是可以实现的：12345&lt;ItemGroup Condition=\" '$(TargetFramework)' == 'net45' \"&gt; &lt;Reference Include=\"System\" /&gt; &lt;Reference Include=\"Microsoft.CSharp\" /&gt; &lt;Compile Include=\"Platforms\\net45\\*.cs\" /&gt;&lt;/ItemGroup&gt; 三、结语说实话MSBuild的项目配置系统还是比较灵活的，以后整个dotnet体系的构建过程也都得到了统一。在dotnet cli中也集成了msbuild,即dotnet build。 GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://maxzhang1985.github.io/tags/dotnet/"}]},{"title":".NET Core中妙用unsafe减少gc提升字符串处理性能","date":"2017-02-23T20:36:31.000Z","path":"2017/02/23/Core使用unsafe方法反转字符串/","text":"昨天在群里讨论怎么样效率的把一个字符串进行反转，一般的情况我们都知道，只要对String对象进行操作，那么就会生成新的String对象，比如”1”+”2” 这样的操作会生成新的String对象。 本文主要想讲述使用unsafe的方式来优化性能，当然在最后面还提到了c# 7.0中的新特性来实现相同功能。 通常我们要反转一个字符中我们都是使用如下方法：123456static string Reverse1(string original)&#123; char[] arr = original.ToCharArray(); Array.Reverse(arr); return new string(arr);&#125; 这种方式，只是通过将数组反转的方式重新排列了字符的顺序，最终还是要重新生成新的String对象，这样无疑会在数据量比较大的时候，会增加GC负担的。 下面主要是今天要说的unsafe的方式。 unsafe关键字表示不安全上下文，该上下文是任何涉及指针的操作所必需的。有关更多信息，请参见不安全代码和指针（C# 编程指南）。可以在类型或成员的声明中使用 unsafe 修饰符。因此，类型或成员的整个正文范围均被视为不安全上下文。 c#在默认情况下生成的都是安全代码，即进行了代码托管（.NET的CLR机制好处之一就是自动进行代码托管，适时的释放内存，程序员便不必考虑资源的回收问题），而此时，指针不能出现在安全代码的编译条件下。如果因需要想在c#中使用指针，那么unsafe便是一个通道（当然在使用前，需在项目属性的生成选项中，选择“允许不安全代码”）。 直接上代码吧:1234567891011121314151617181920212223242526272829string hello = \"hello world你好\";int len = hello.Length * 2;fixed (char* strs = hello)&#123; byte* start = (byte*)strs; byte* end = start + len - 1; byte[] ch = new byte[2]; if (start != null) &#123; while (start &lt; end) &#123; ch[0] = *start; ch[1] = *(start + 1); *start = *(end-1); *(start+1) = *(end); start = start + 2; *(end - 1) = ch[0]; *(end) = ch[1]; end = end - 2; &#125; &#125;&#125; fixed 语句设置指向托管变量的指针并在 statement 执行期间“钉住”该变量。如果没有 fixed 语句，则指向可移动托管变量的指针的作用很小，因为垃圾回收可能不可预知地重定位变量。C# 编译器只允许在 fixed 语句中分配指向托管变量的指针。(这句话是机器翻译的,呵呵) 好了最终的结果就是: hello=”好你dlrow olleh” , 但是我们并没有new String哦！ 其实对说新的C# 7.0来说，它为我们带来了新ref关键字，来处理本地引用（Ref locals ）。 让我们来开一下脑洞，下面是段成立的代码: 1234567string hello = \"hello world你好\";ref char strRef = ref getStringArray(ss, 0);static ref char getStringArray(char[] str,int index)&#123; return ref str[index];&#125; strRef是什么？我们是不是可以通过这样的方式，来达到与使用指针相同的目地？请继续关注下一篇文章。","tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://maxzhang1985.github.io/tags/dotnet/"}]},{"title":".NET Core SDK相关下载(含历史版本)","date":"2017-02-21T15:04:18.000Z","path":"2017/02/21/NET-Core-SDK相关下载-含历史版本/","text":".NET Core 官方最新版下载地址：https://www.microsoft.com/net/download/core .NET Core Release版本下载地址：https://github.com/dotnet/core/blob/master/release-notes/download-archive.md","tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://maxzhang1985.github.io/tags/dotnet/"}]},{"title":"在ASP.NET Core下使用SignalR技术","date":"2017-02-21T14:31:12.000Z","path":"2017/02/21/在ASP-NET-Core下使用SignalR技术/","text":"一、前言 上次我们讲到过如何在ASP.NET Core中使用WebSocket,没有阅读过的朋友请参考 WebSocket in ASP.NET Core 文章 。这次的主角是SignalR它为我们提供了简化操作WebSocket的框架。 ASP .NET SignalR 是一个ASP.NET 下的类库，可以在ASP.NET 的Web项目中实现实时通信。什么是实时通信的Web呢？就是让客户端（Web页面）和服务器端可以互相通知消息及调用方法，当然这是实时操作的。WebSockets是HTML5提供的新的API，可以在Web网页与服务器端间建立Socket连接，当WebSockets可用时（即浏览器支持Html5）SignalR使用WebSockets，当不支持时SignalR将使用其它技术来保证达到相同效果。SignalR当然也提供了非常简单易用的高阶API，使服务器端可以单个或批量调用客户端上的JavaScript函数，并且非常 方便地进行连接管理，例如客户端连接到服务器端，或断开连接，客户端分组，以及客户端授权，使用SignalR都非常容易实现。 二、SignalR目前情况 我们知道在ASP.NET Core 1.0.x 版本中并没有包含SignalR，但是SignalR技术计划集成在ASP.NET Core 1.2版本中，并且它的开发团队还要使用TypeScript对它的javascript客户端进行重写，服务端方面也会贴近ASP.NET Core的开发方式，比如会集成到ASP.NET Core依赖注入框架中。 目前的情况就是在1.0中无法使用SignalR技术，本文实现的Demo都是在1.1下进行的。 三、集成SignalR 当然ASP.NET Core 1.2离正式发布还有一段时间，目前想集成SignalR都不是现成的方案，我们要通过手动的方式集成SignalR。 要在ASP.NET Core中使用SignalR，要先引用Microsoft.AspNetCore.SignalR.Server 、 Microsoft.AspNetCore.WebSockets 的NuGet Package包。 当然上面也说过目前没有ASP.NET Core没有集成SignalR，所以NUGET上也找不到SignalR的程序包，想添加引用我们就得去MyGet上去找找。 1.添加NuGet源 在程序根目录新建一个命为NuGet.Config的文件内容如下：12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;configuration&gt; &lt;packageSources&gt; &lt;clear/&gt; &lt;add key=\"aspnetcidev\" value=\"https://dotnet.myget.org/F/aspnetcore-ci-dev/api/v3/index.json\"/&gt; &lt;add key=\"api.nuget.org\" value=\"https://api.nuget.org/v3/index.json\"/&gt; &lt;/packageSources&gt;&lt;/configuration&gt; 当然我们也可以通过在Visual Studio中设置 NuGet Packages的源，来引用这个程序集。 2.在project.json添加引用12\"Microsoft.AspNetCore.SignalR.Server\": \"0.2.0-*\",\"Microsoft.AspNetCore.WebSockets\": \"1.0.0-*\" 可以注意到SignalR的版本是0.2.0的alpha版本，所以后续版本可能变化也会比较大！ 听说是好重写的。 值得注意的是，SignalR目前只能在ASP.NET Core 1.1及以上版本上使用，在这个文章中我使用的.NET Core SDK版本为 1.0.0-preview2-003131 ，所以引用有问题的同学可以尝试把CoreApp版本改为1.1，所有AspNetCore的程序集也都改变为1.1的版本。 3.添加配置代码 我们需要在Startup类中的 ConfigureServices方法中添加如下代码：1234567public void ConfigureServices(IServiceCollection services)&#123; services.AddSignalR(options =&gt; &#123; options.Hubs.EnableDetailedErrors = true; &#125;);&#125; 在Startup类中的Configure方法中添加如下代码：12app.UseWebSockets();app.UseSignalR(); 4.添加一个HUB类 这里我们只实现一个小Demo，一个简单的聊天室，多个人进入可以看到各自发送的信息:12345678910111213141516171819public class ChatHub : Hub&#123; public static List&lt;string&gt; ConnectedUsers; public void Send(string originatorUser, string message) &#123; Clients.All.messageReceived(originatorUser, message); &#125; public void Connect(string newUser) &#123; if (ConnectedUsers == null) ConnectedUsers = new List&lt;string&gt;(); ConnectedUsers.Add(newUser); Clients.Caller.getConnectedUsers(ConnectedUsers); Clients.Others.newUserAdded(newUser); &#125;&#125; 5.客户端支持 在wwwroot目录下创建一个名为chat.html的Html静态文件，内容如下：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Awesome Chat Application&lt;/title&gt; &lt;meta charset=\"utf-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;style type=\"text/css\"&gt; .userListDiv&#123; float: right; &#125; &lt;/style&gt; &lt;ul id=\"messages\"&gt;&lt;/ul&gt; &lt;input type=\"text\" id=\"messageBox\" /&gt; &lt;input type=\"button\" id=\"sendMessage\" value=\"Send Message!\" /&gt; &lt;div class=\"userListDiv\"&gt; &lt;ul id=\"userList\"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=\"http://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.1.0.min.js\"&gt;&lt;/script&gt; &lt;script src=\"http://ajax.aspnetcdn.com/ajax/signalr/jquery.signalr-2.2.1.min.js\"&gt;&lt;/script&gt; &lt;script src=\"signalr/hubs\"&gt;&lt;/script&gt; &lt;script src=\"chat.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同目录下建立一个chat.js添加要实现功能的脚本：1234567891011121314151617181920212223242526272829var userName = prompt(\"Enter your name: \");var chat = $.connection.chatHub;chat.client.messageReceived = function (originatorUser, message) &#123; $(\"#messages\").append('&lt;li&gt;&lt;strong&gt;' + originatorUser + '&lt;/strong&gt;: ' + message);&#125;;chat.client.getConnectedUsers = function (userList) &#123; for (var i = 0; i &lt; userList.length; i++) addUser(userList[i]);&#125;;chat.client.newUserAdded = function (newUser) &#123; addUser(newUser);&#125;$(\"#messageBox\").focus();$(\"#sendMessage\").click(function () &#123; chat.server.send(userName, $(\"#messageBox\").val()); $(\"#messageBox\").val(\"\"); $(\"#messageBox\").focus();&#125;);$(\"#messageBox\").keyup(function (event) &#123; if (event.keyCode == 13) $(\"#sendMessage\").click();&#125;);function addUser(user)&#123; $(\"#userList\").append('&lt;li&gt;' + user + '&lt;/li&gt;');&#125;$.connection.hub.logging = true;$.connection.hub.start().done(function () &#123; chat.server.connect(userName);&#125;); 最后我们来运行它吧： 四、最后 附上一个可用的Demo：https://github.com/maxzhang1985/AspNetCore.SignalRDemo GitHub：https://github.com/maxzhang1985/YOYOFx 如果觉还可以请Star下， 欢迎一起交流。 .NET Core 开源学习群：214741894","tags":[{"name":"dotnet aspnet","slug":"dotnet-aspnet","permalink":"http://maxzhang1985.github.io/tags/dotnet-aspnet/"}]},{"title":"小程序开发注意事项","date":"2017-02-21T10:49:18.000Z","path":"2017/02/21/小程序开发注意事项/","text":"1.不能跨组件传递状态状态传递主要是指不管组件间是树型关系还是兄弟关系，组件都不能像Html中的Dom结构一样使用Id访问某一节点的状态属性值，如下面一个例子：12345678910&lt;swiper indicator-dots=\"&#123;&#123;indicatorDots&#125;&#125;\" bindchange=\"onswiperChange\" autoplay=\"&#123;&#123;autoplay&#125;&#125;\" interval=\"&#123;&#123;interval&#125;&#125;\" duration=\"&#123;&#123;duration&#125;&#125;\"&gt; &lt;block wx:key=\"bid\" wx:for=\"&#123;&#123;imgUrls&#125;&#125;\"&gt; &lt;swiper-item&gt; &lt;navigator url=\"../logs/logs?index=&#123;&#123;swiperindex&#125;&#125;\"&gt; &lt;image src=\"&#123;&#123;item&#125;&#125;\" class=\"slide-image\" mode=\"scaleToFill\" /&gt; &lt;/navigator&gt; &lt;/swiper-item&gt; &lt;/block&gt;&lt;/swiper&gt; 在这个实例中如果我想在navigator组件中的url属性中访问swiper组件的CurrentIndex属性是不可能的，只能通过绑定swiper的事件再使用变量的方式进行绑定访问。 2.wx:key的使用在模板创建使用for生成组件时，使用wx:key，可以在执行setData后刷新界面元素时不重新创建组件，而仅仅改变状态或顺序。12345678910 data: &#123; input_data: [ &#123; id: 1, unique: \"unique1\" &#125;, &#123; id: 2, unique: \"unique2\" &#125;, &#123; id: 3, unique: \"unique3\" &#125;, &#123; id: 4, unique: \"unique4\" &#125;, ] &#125; &lt;input value=\"id:&#123;&#123;item.id&#125;&#125;\" wx:for=\"&#123;input_data&#125;\" wx:key=\"unique\"/&gt; 有wx:key的情况添加元素或改变元素顺序导致数据改变时，会校正带有Key的组件（可通过key识别各组件），框架会根据“目前数据”，重新排序各组件，而不是重新创建，使组件保持自身的状态，列表渲染效率高。 无wx:key的情况添加元素或改变元素顺序导致数据改变时，此时各组件没有key(无法识别各组件)框架会被迫根据“目前数据”重新创建各组件，使组件重置初始状态（原有状态自然被清空），列表渲染效率低。 wx:key=”*this”表示绑定的是数据自身，如数据为一个数据数组或字符串数组时。 3.修改数据数组绑定的界面元素数组：http://www.w3school.com.cn/jsref/jsref_obj_array.asp 事件：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html1234567891011121314edit:function (e)&#123; //这个参数“e”的具体作用，请参考微信小程序官方提供的说明，地址为 var dataset = e.target.dataset; //元素节点的attribute: data-index=\"&#123;&#123;index&#125;&#125;\"传递过来的，是为识别正在编辑修改哪个数组。 var Index = dataset.index; //我们要修改的数组 this.data.list[Index].name = '修改了内容'+new Date().getTime(); //将合拼之后的数据，发送到视图层，即渲染页面 //大伙请记录，修改了数据后，一定要再次执行`this.setData()`，页面才会渲染数据的。 this.setData(&#123; list:this.data.list &#125;);&#125; 4.删除某条绑定的界面元素12345678910remove:function (e)&#123;var dataset = e.target.dataset;var Index = dataset.index;//通过`index`识别要删除第几条数据，第二个数据为要删除的项目数量，通常为1this.data.list.splice(Index,1);//渲染数据this.setData(&#123; list:this.data.list&#125;); &#125; 5.嵌套绑定嵌套时要善用 wx:for-item12345678&lt;view class=\"pad10\" wx:for=\"&#123;&#123;twoList&#125;&#125;\" wx:key=\"id\"&gt; &lt;view&gt; &#123;&#123;index+1&#125;&#125;、&#123;&#123;item.name&#125;&#125; &lt;/view&gt; &lt;view wx:for=\"&#123;&#123;item.twodata&#125;&#125;\" wx:for-item=\"twodata\" wx:key=\"id\"&gt; ----&#123;&#123;twodata.name&#125;&#125;---&#123;&#123;item.name&#125;&#125; &lt;/view&gt;&lt;/view&gt; 6.布局系统小程序采用与CSS3和React一样的布局系统：FlexFlex参考资源： http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool http://blog.csdn.net/qq_34281962/article/details/52729215 7.小程序限制问题（1）数据绑定 绑定表达式不能执行方法，只能处理简单的运算如 “+ -*/”，如果遇到集合数据绑定中需要数据格式的转换，就需要遍历list并对每个item进行格式化，再执行setData刷新界面。 （2）页面跳转 A页面–&gt;B页面，B页面返回A，如何触发A的刷新。方案：在A页面的onshow事件里写A的初始化数据方法。 （3）样式 本地资源无法通过 css 获取 可以使用网络图片 （4）缓存 wx.setStorage() 目前每个小程序限制5M （5）网络请求 Post请求需要加表单提交时的头信息 header: ‘content-type’: ‘application/x-www-form-urlencoded’","tags":[{"name":"wechat","slug":"wechat","permalink":"http://maxzhang1985.github.io/tags/wechat/"}]}]